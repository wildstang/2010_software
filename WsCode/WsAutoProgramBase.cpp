//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoProgramBase.cpp
//  @ Date : 2/8/2009
//  @ Author : 
//
//


#include "WsAutoProgramBase.h"
#include "WsAutoNStepBase.h"
#include "WsDriveVector.h"
#include "WsDriveBaseCrabSingle.h"
#include "WsKicker.h"
#include "WsKickerRange.h"
#include "WsKickerLoft.h"
#include "WsAccumulator.h"
#include "Timer.h"
#include "WsPid.h"

float WsAutoProgramBase::convertDelay(StartDelayT delay)
{
  // THIS ASSUMES THAT THE PROGRAM IS AN N STEP BASE....IF WE ADD MORE TYPES WE
  // NEED TO UPDATE THIS TO PUSH THE DELAY LOGIC SOMEWHERE ELSE
  return WsAutoNStepBase::convertDelay(delay);
}

/**
* Constructs a WsAutoProgramBase.  Creates a stopped timer
*/
WsAutoProgramBase::WsAutoProgramBase()
{
    ap_driveBase = NULL;
    ap_timer = new Timer();
    if(ap_timer != NULL)
    {
        ap_timer->Stop();
    }
    a_timerStartFlag = true;
    a_crabEnable = true;
}

/**
* Destructs a WsAccumulator.  Cleans up the instantiated timer
*/
WsAutoProgramBase::~WsAutoProgramBase()
{
    if(ap_timer != NULL)
    {
        delete ap_timer;
    }
    ap_timer = NULL;
}

/**
* The default implementation of the run function that the WsAutonomousManager
* will call every iteration.  The default is to not move.
* @returns A boolean value representing whether the progam is done
*/
bool WsAutoProgramBase::run(void )
{
    bool done = true;
    turnOffDriveBase();
    turnOffAppendages();
    return done;
}

/**
* Assigns a drive base object to the class member
* @param p_driveBase The drive base to use
*/
void WsAutoProgramBase::assignDriveBase(WsDriveBaseCrabSingle* p_driveBase)
{
    ap_driveBase = p_driveBase;
}

void WsAutoProgramBase::assignAppendages(WsKicker* p_kicker,
                                         WsAccumulator* p_accumulator)
{
    ap_kicker = p_kicker;
    ap_accumulator = p_accumulator;
}

void WsAutoProgramBase::setStartDelay(StartDelayT delay)
{
     a_startDelay = delay;
}

void WsAutoProgramBase::setPresetWheels(bool presetWheels)
{
    a_presetWheels = presetWheels;
}

void WsAutoProgramBase::setCrabEnableState(bool enabled)
{
    a_crabEnable = enabled;
}

/**
* Turns off all drive base outputs.
*/
void WsAutoProgramBase::turnOffDriveBase(void )
{
    WsDriveVector v(0,0);
    if(ap_driveBase != NULL)
    {
        ap_driveBase->setVector(&v);
        ap_driveBase->setManualSpeed(0);
    }
}

/**
* Turns off all appendage outputs.
*/
void WsAutoProgramBase::turnOffAppendages(void )
{
    turnOffKicker();
    turnOffAccumulator();
}

void WsAutoProgramBase::turnOffKicker(void )
{
    if(ap_kicker != NULL)
    {
        ap_kicker->resetState();
    }
}

void WsAutoProgramBase::turnOffAccumulator(void )
{
    if(ap_accumulator != NULL)
    {
        ap_accumulator->setState(WsAccumulator::ACCUM_OFF);
    }
}

/**
* A non-blocking delay function that returns true when it is called and the time has elapsed.
* The start flag is used to keep track of whether a timer is stopped and needs to be started again.
* @param delayTime How long to wait until the time is considered elapsed
* @param *p_currentTime Passed in by reference, it will be populated with the current timer value
* @returns A boolean value for whether the time has elapsed
*/
bool WsAutoProgramBase::delay(double delayTime, double* p_currentTime, bool forceStop)
{
    double time = 0;
    bool done = false;

    if(ap_timer != NULL)
    {
        if (a_timerStartFlag == true)
        {
            ap_timer->Start();
            a_timerStartFlag = false;
        }

        time = ap_timer->Get();

        if((forceStop == true) || (time > delayTime))
        {
            if(forceStop)
            {
                printf("FORCE ");
            }
            ap_timer->Stop();
            ap_timer->Reset();
            a_timerStartFlag = true;
            done = true;
        }

        *p_currentTime = time;
    }
    else
    {
        done = true;
    }

    printf("TIME: (%.2f, %.2f) ", delayTime, time);
    return done;
}

/**
* Set the drive output based on the input parameters
* @param p_driveVector The vector to drive at
* @param crabAngle The angle at which to set the crab position
*/
void WsAutoProgramBase::setDrive(WsDriveVector* p_driveVector, float crabAngle)
{
    if(ap_driveBase != NULL)
    {
        printf("DRIVE: (%4f, %4f) ",p_driveVector->a_speed, p_driveVector->a_direction);
        ap_driveBase->setVector(p_driveVector);
        if(a_crabEnable == true)
        {
            ap_driveBase->setCrabAngle(crabAngle);
        }
        else
        {
            ap_driveBase->setManualSpeed(0);
        }
    }
}

/**
* A non-blocking function that uses the input parameters to drive a certain way for a certain amount of time.
* @param p_driveVector The vector to drive at
* @param crabAngle The angle at which to set the crab position
* @param delayTime How long to wait until the time is considered elapsed
* @param *p_currentTime Passed in by reference, it will be populated with the current timer value
* @returns A boolean value for whether the time has elapsed
*/
bool WsAutoProgramBase::driveByTime(WsDriveVector* p_driveVector, float crabAngle,
                                    double driveTime, double* p_currentTime)
{
    setDrive(p_driveVector, crabAngle);
    return delay(driveTime, p_currentTime);
}

/**
* A non-blocking function that coasts (i.e. turns drive motors off) at a certain crab angle for a certain amount of time
* @param crabAngle The angle at which to set the crab position
* @param delayTime How long to wait until the time is considered elapsed
* @param *p_currentTime Passed in by reference, it will be populated with the current timer value
* @returns A boolean value for whether the time has elapsed
*/
bool WsAutoProgramBase::coastPointWheels(float crabAngle,
                                         double delayTime,
                                         double* p_currentTime)
{
    WsDriveVector v(0,0);

    return driveByTime(&v, crabAngle, delayTime, p_currentTime);
}

bool WsAutoProgramBase::driveByEncoder(WsDriveVector* p_driveVector,
                                       float crabAngle,
                                       WsDriveBase::EncoderLocationT encoderLoc,
                                       INT32 encoderTarget,
                                       double timeout,
                                       double* p_currentTime,
                                       bool reinit)
{
    bool done = false;

    WsEncoder* enc;
    INT32 encoderVal = 0;
    double time = 0;

    p_driveVector->a_y = -p_driveVector->a_speed;

    enc = ap_driveBase->getEncoder(encoderLoc);

    if(enc != NULL)
    {
        if(ap_timer != NULL)
        {
            if (a_timerStartFlag == true || reinit == true)
            {
                printf("REINIT ");
                enc->resetRelCount();
                enc->Start();

                ap_timer->Reset();
                ap_timer->Start();

                a_timerStartFlag = false;
            }

            time = ap_timer->Get();
            *p_currentTime = time;

            printf("Time %f ", time);
            if(time < timeout)
            {
                encoderVal = enc->getRelCount();
                printf("ETarg: %d  ECur: %d ", encoderTarget, encoderVal);

                if(encoderTarget >= 0)
                {
                    if(encoderVal >= encoderTarget)
                    {
                        printf("DONE POS ");
                        done = true;
                    }
                }
                else
                {
                    if(encoderVal <= encoderTarget)
                    {
                        printf("DONE NEG ");
                        done = true;
                    }
                }
            }
            else
            {
                printf("TIMEOUT ");
                ap_timer->Stop();
                ap_timer->Reset();
                done = true;
            }
        }
        else
        {
            printf("NO TIMER ");
            done = true;
        }

        if(done == false)
        {
            printf(" D %4f %4f", p_driveVector->a_speed, p_driveVector->a_direction);
            setDrive(p_driveVector, crabAngle);
        }
        else
        {
            printf(" S ");
            //enc->Stop();
        }
    }
    else
    {
        printf("NO ENCODER ");
        done = true;
    }

    if(done == true)
    {
        printf("STOP ");
        WsDriveVector stopVector(0,0);
        setDrive(&stopVector, crabAngle);
        a_timerStartFlag = true;
    }

    return done;
}

bool WsAutoProgramBase::driveUntilPress(WsDriveVector* p_driveVector,
                                        float crabAngle,
                                        double timeout,
                                        double* p_currentTime,
                                        bool reinit)
{
    static UINT8 loopCount = 0;
    static bool delayState = false;
    bool done = false;

    if(reinit == true)
    {
        delayState = false;
    }

    if(ap_kicker != NULL)
    {
        if(delayState == false)
        {
            delayState = delay(timeout, p_currentTime);
            printf("D: %3.3f %3.3f ", timeout, *p_currentTime);

            if(ap_kicker->isBallPossessed())
            {
                if(loopCount < 5)
                {
                    printf("BALL: %d ", loopCount);
                    setDrive(p_driveVector, crabAngle);
                    loopCount++;
                }
                else
                {
                    printf("STOP: %d ", loopCount);
                    WsDriveVector stopVector(0,0);
                    setDrive(&stopVector, crabAngle);
                    done = true;
                    loopCount = 0;
                    // Stop the delay timer
                    delayState = delay(timeout, p_currentTime, true);
                    delayState = false;
                }
            }
            else
            {
                printf("WAIT");
                setDrive(p_driveVector, crabAngle);
                loopCount = 0;
            }
        }
        else
        {
            printf("T.O.");
            WsDriveVector stopVector(0,0);
            setDrive(&stopVector, crabAngle);
            loopCount = 0;
        }
    }
    else
    {
        printf("NO KICKER!\n");
    }

    return done;
}


bool WsAutoProgramBase::driveByDistancePid(WsDriveVector* p_driveVector,
        float crabAngle,
        WsDriveBase::EncoderLocationT encoderLoc,
        INT32 encoderTarget,
        WsPid* p_pid,
        double timeout,
        double* p_currentTime,
        bool reinit)
{
    bool done = false;

    WsEncoder* enc;
    INT32 encoderVal = 0;
    double time = 0;

    enc = ap_driveBase->getEncoder(encoderLoc);

    if(enc != NULL)
    {
        if(ap_timer != NULL)
        {
            if (a_timerStartFlag == true || reinit == true)
            {
                enc->resetRelCount();
                enc->Start();

                p_pid->resetErrorSum();

                ap_timer->Reset();
                ap_timer->Start();

                a_timerStartFlag = false;
            }

            time = ap_timer->Get();
            *p_currentTime = time;

            printf("Time %f ", time);
            if(time < timeout)
            {
                encoderVal = enc->getRelCount();
                p_pid->setDesiredValue(encoderTarget);
                p_driveVector->a_y = -1 * p_pid->calcPid(encoderVal);

                printf("ETarg: %d  ECur: %d Speed: %3f", encoderTarget, encoderVal, p_driveVector->a_y);

                if(p_pid->isDone() == true)
                {
                        printf("DONE EPID ");
                        done = true;
                }
            }
            else
            {
                printf("TIMEOUT ");
                ap_timer->Stop();
                ap_timer->Reset();
                done = true;
            }
        }
        else
        {
            printf("NO TIMER ");
            done = true;
        }

        if(done == false)
        {
            printf(" P %4f %4f", p_driveVector->a_y, p_driveVector->a_direction);
            setDrive(p_driveVector, crabAngle);
        }
        else
        {
            printf(" S ");
            //enc->Stop();
        }
    }
    else
    {
        printf("NO ENCODER ");
        done = true;
    }

    if(done == true)
    {
        printf("STOP ");
        WsDriveVector stopVector(0,0);
        setDrive(&stopVector, crabAngle);
        a_timerStartFlag = true;
    }

    return done;
}


bool WsAutoProgramBase::stowKicker(void)
{
    bool done = false;
    WsKicker::WsKickerStateT kickerState;
    WsKicker::WsKickerCommandT command = WsKicker::KICKER_CMD_NONE;

    if(ap_kicker != NULL)
    {
        kickerState = ap_kicker->getState();

        /*
        ap_kicker->setCommand(WsKicker::KICKER_CMD_STOW);

        done = (kickerState == WsKicker::KICKER_STATE_STOW ||
                kickerState == WsKicker::KICKER_STATE_SET_FAR_KICK);
                */

        switch(kickerState)
        {
            case WsKicker::KICKER_STATE_STOW:
            case WsKicker::KICKER_STATE_SET_FAR_KICK:
                done = true;
                break;

            case WsKicker::KICKER_STATE_SET_NEAR_KICK:
            case WsKicker::KICKER_STATE_LOAD_KICKER_NEAR:
            case WsKicker::KICKER_STATE_LOAD_KICKER_FAR:
            case WsKicker::KICKER_STATE_LATCH_KICKER:
                command = WsKicker::KICKER_CMD_STOW;
                done = false;
                break;

            default:
                done = false;
                break;
        }

        ap_kicker->setCommand(command);
    }
    else
    {
        done = true;
    }
    printf("STOW: state %d cmd %d ", kickerState, command);

    return done;
}
bool WsAutoProgramBase::setKickerRange(WsKickerRange::WsKickerRangeT range)
{
    bool done = false;
    WsKicker::WsKickerStateT kickerState;
    WsKicker::WsKickerCommandT command = WsKicker::KICKER_CMD_NONE;

    if(ap_kicker != NULL)
    {
        kickerState = ap_kicker->getState();

        switch(kickerState)
        {
            case WsKicker::KICKER_STATE_STOW:
            case WsKicker::KICKER_STATE_SET_FAR_KICK:
                if(range == WsKickerRange::KICKER_RANGE_NEAR)
                {
                    command = WsKicker::KICKER_CMD_SET_RANGE_NEAR;
                }
                else
                {
                    done = true;
                }

                break;

            case WsKicker::KICKER_STATE_SET_NEAR_KICK:
            case WsKicker::KICKER_STATE_LATCH_KICKER:
                if(range == WsKickerRange::KICKER_RANGE_FAR)
                {
                    command = WsKicker::KICKER_CMD_SET_RANGE_FAR;
                }
                else
                {
                    done = true;
                }

                break;

            case WsKicker::KICKER_STATE_INIT:
                done = false;
                break;

            default:
                done = true;
                break;
        }

        ap_kicker->setCommand(command);
    }
    else
    {
        done = true;
    }
    printf("RANGE: state %d cmd %d ", kickerState, command);

    return done;
}

bool WsAutoProgramBase::loadKicker(WsKickerRange::WsKickerRangeT range)
{
    bool done = false;
    WsKicker::WsKickerStateT kickerState;
    WsKicker::WsKickerCommandT command = WsKicker::KICKER_CMD_NONE;

    if(ap_kicker != NULL)
    {
        kickerState = ap_kicker->getState();

        switch(kickerState)
        {
            case WsKicker::KICKER_STATE_STOW:
            case WsKicker::KICKER_STATE_SET_FAR_KICK:
            case WsKicker::KICKER_STATE_SET_NEAR_KICK:
            case WsKicker::KICKER_STATE_LATCH_KICKER:
                command = WsKicker::KICKER_CMD_PREPARE_TO_KICK;
                done = false;
                break;

            case WsKicker::KICKER_STATE_LOAD_KICKER_NEAR:
                if(range == WsKickerRange::KICKER_RANGE_FAR)
                {
                    command = WsKicker::KICKER_CMD_SET_RANGE_FAR;
                    done = false;
                }
                else
                {
                    done = true;
                }
                break;

            case WsKicker::KICKER_STATE_LOAD_KICKER_FAR:
                if(range == WsKickerRange::KICKER_RANGE_NEAR)
                {
                    command = WsKicker::KICKER_CMD_SET_RANGE_NEAR;
                    done = false;
                }
                else
                {
                    done = true;
                }
                break;

            default:
                done = false;
                break;
        }

        ap_kicker->setCommand(command);
    }
    else
    {
        done = true;
    }
    printf("LOAD: state %d cmd %d ", kickerState, command);

    return done;
}

bool WsAutoProgramBase::babyKick(WsKickerLoft::WsKickerLoftT loft)
{
    /* Assumes that we in set near state */
    bool done = false;
    WsKicker::WsKickerStateT kickerState;
    static WsKicker::WsKickerStateT kickerStatePrev = WsKicker::KICKER_STATE_INIT;
    static WsKicker::WsKickerStateT stopState = WsKicker::KICKER_STATE_SET_NEAR_KICK;
    static bool kicking = false;
    static WsKicker::WsKickerCommandT command = WsKicker::KICKER_CMD_NONE;

    if(ap_kicker != NULL)
    {
        printf("BABY: ");

        kickerState = ap_kicker->getState();

        if((kicking == true) &&
                (kickerState == stopState) &&
                (kickerState != kickerStatePrev))
        {
            command = WsKicker::KICKER_CMD_NONE;
            kicking = false;
            kickerStatePrev = WsKicker::KICKER_STATE_INIT;
            done = true;
        }
        else if(kickerState == WsKicker::KICKER_STATE_SET_NEAR_KICK)
        {
            if((kicking == false) && ap_kicker->isBallPossessed())
            {
                printf("BALL ");
                if(loft == WsKickerLoft::KICKER_LOFT_LOW)
                {
                  command = WsKicker::KICKER_CMD_KICK_BABY_LOW;
                }
                else
                {
                  command = WsKicker::KICKER_CMD_KICK_BABY_HIGH;
                }
                kicking = true;
            }
            else
            {
                printf("WAIT ");
            }
        }

        ap_kicker->setCommand(command);

        printf("prev %d state %d cmd %d stop (%d, %d) ", kickerStatePrev, kickerState, command, kicking, stopState);
        kickerStatePrev = kickerState;
    }

    return done;

}

bool WsAutoProgramBase::kick(WsKickerLoft::WsKickerLoftT loft, bool lastKick,
                                      WsKickerRange::WsKickerRangeT nextRange)
{
    /* Assumes that we're in a loaded state!! */
    bool done = false;
    WsKicker::WsKickerStateT kickerState;
    static WsKicker::WsKickerStateT stopState = WsKicker::KICKER_STATE_LOAD_KICKER_NEAR;
    static bool kicking = false;
    static WsKicker::WsKickerCommandT command = WsKicker::KICKER_CMD_NONE;

    if(ap_kicker != NULL)
    {
        printf("KICK: ");
        kickerState = ap_kicker->getState();
        if(kickerState == WsKicker::KICKER_STATE_LOAD_KICKER_NEAR ||
                kickerState == WsKicker::KICKER_STATE_LOAD_KICKER_FAR)
        {
            if((kicking == false) && ap_kicker->isBallPossessed())
            {
                printf("BALL ");
                if(loft == WsKickerLoft::KICKER_LOFT_LOW)
                {
                    command = WsKicker::KICKER_CMD_KICK_LOW;
                }
                else
                {
                    command = WsKicker::KICKER_CMD_KICK_HIGH;
                }

                if(kickerState == WsKicker::KICKER_STATE_LOAD_KICKER_NEAR ||
                   lastKick == true)
                {
                    stopState = WsKicker::KICKER_STATE_LATCH_KICKER;
                }
                else
                {
                    if(nextRange == WsKickerRange::KICKER_RANGE_NEAR)
                    {
                      stopState = WsKicker::KICKER_STATE_LATCH_KICKER;
                    }
                    else
                    {
                      stopState = WsKicker::KICKER_STATE_SET_FAR_KICK;
                    }
                }
                kicking = true;
            }
            else
            {
                printf("WAIT ");
            }
        }
        else if((kicking == true) && (kickerState == stopState))
        {
            command = WsKicker::KICKER_CMD_NONE;
            stopState = WsKicker::KICKER_STATE_LOAD_KICKER_NEAR;
            kicking = false;
            done = true;
        }

        ap_kicker->setCommand(command);

        printf(" state %d cmd %d stop (%d, %d) ", kickerState, command, kicking, stopState);
    }

    return done;

}

bool WsAutoProgramBase::kickAndReload(WsKickerLoft::WsKickerLoftT loft,
                                      WsKickerRange::WsKickerRangeT reloadRange)
{
    /* Assumes that we're in a loaded state!! */
    bool done = false;
    static bool hasKicked = false;
    WsKicker::WsKickerStateT kickerState;
    WsKicker::WsKickerCommandT command = WsKicker::KICKER_CMD_NONE;

    if(ap_kicker != NULL)
    {
        kickerState = ap_kicker->getState();
        if(hasKicked == false)
        {
            if(kickerState == WsKicker::KICKER_STATE_LOAD_KICKER_NEAR ||
               kickerState == WsKicker::KICKER_STATE_LOAD_KICKER_FAR)
            {
                if(loft == WsKickerLoft::KICKER_LOFT_LOW)
                {
                    command = WsKicker::KICKER_CMD_KICK_LOW;
                }
                else
                {
                    command = WsKicker::KICKER_CMD_KICK_HIGH;
                }
            }
            else
            {
                hasKicked = true;
            }

            ap_kicker->setCommand(command);

            done = false;
        }
        else
        {
            if(reloadRange != WsKickerRange::KICKER_RANGE_NONE)
            {
                // We've kicked.  Time to reload
                done = loadKicker(reloadRange);
            }
            else
            {
                done = true;
            }
        }
        printf("KICK: state %d cmd %d ", kickerState, command);
    }
    else
    {
        done = true;
    }

    if(done == true)
    {
        hasKicked = false;
    }

    return done;

}

bool WsAutoProgramBase::setAccumState(WsAccumulator::WsAccumStateT state, WsAccumulator::WsBarStateT barState)
{
    bool forceOff = false;

    if(ap_accumulator != NULL)
    {
        if(ap_kicker != NULL)
        {
            forceOff = ap_kicker->isKicking();
        }

        ap_accumulator->setState(state, forceOff);
        ap_accumulator->setBarState(barState, false);
        printf("ACCUM: %d BAR: %d", ap_accumulator->getState(), ap_accumulator->getBarState());
    }

    // Accumulator only takes one loop to set state, so return true all the time
    return true;
}

