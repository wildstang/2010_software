//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutonomousMgr.h
//  @ Date : 2/8/2009
//  @ Author : 
//
//


#if !defined(_WSAUTONOMOUSMGR_H)
#define _WSAUTONOMOUSMGR_H

#include <stdio.h>
#include "WsAutoProgramBase.h"

class WsControllerAxis;
class WsDsAnalog;
class WsDriveBaseCrabSingle;
class WsKicker;
class WsAccumulator;
class WsControllerButton;
class WsDashboard;
class WsDriverStationLED;

// TODO MOVE THESE TO MEMBERS
#define PROG_NAME_LEN 15

// Constants for autonomous program dial

#define PROG11_MIN -1
#define PROG11_MAX -.88

#define PROG10_MIN (PROG_11_MAX)
#define PROG10_MAX -.7

#define PROG9_MIN (PROG10_MAX)
#define PROG9_MAX -.55

#define PROG8_MIN (PROG9_MAX)
#define PROG8_MAX -.35

#define PROG7_MIN (PROG8_MAX)
#define PROG7_MAX -.18

#define PROG6_MIN (PROG7_MAX)
#define PROG6_MAX 0

#define PROG5_MIN (PROG6_MAX)
#define PROG5_MAX .12

#define PROG4_MIN (PROG5_MAX)
#define PROG4_MAX .33

#define PROG3_MIN (PROG4_MAX)
#define PROG3_MAX .5

#define PROG2_MIN (PROG3_MAX)
#define PROG2_MAX .7

#define PROG1_MIN (PROG2_MAX)
#define PROG1_MAX 1

// Constants for autonomous starting position
#define POSITION1_MIN .3
#define POSITION1_MAX 1

#define POSITION2_MIN -.3
#define POSITION2_MAX .3

#define POSITION3_MIN -1
#define POSITION3_MAX -.3

// Constants for autonomous delay
#define AUTO_DELAY0_MIN .3
#define AUTO_DELAY0_MAX 1

#define AUTO_DELAY1_MIN -.3
#define AUTO_DELAY1_MAX .3

#define AUTO_DELAY2_MIN -1
#define AUTO_DELAY2_MAX -.3

/**
* This is the main coordinator for everything related to autonomous.  It handles lockin while disabled and program instantiation and execution when autonomous is enabled
*/
class WsAutonomousMgr
{
public:

    typedef enum
    {
        START_CLOSE, /**< The robot is starting in the close zone */
        START_MID,   /**< The robot is starting in the middle zone */
        START_FAR,   /**< The robot is starting in the far zone */
    } StartingPositionT;

    static const bool a_lockInStateOff = false; /*!< A constant for when the lockin state is off */
    static const bool a_lockInStateOn = true;   /*!< A constant for when the lockin state is on */

    WsAutonomousMgr(WsControllerAxis* p_progNumSelector,
                    WsControllerAxis* p_positionSelector,
                    WsControllerAxis* p_delaySelector,
                    WsControllerButton* p_lockInSwitch,
                    WsDriverStationLED* p_lockInLed);

    WsAutonomousMgr(WsDsAnalog* p_progNumSelector,
                    WsDsAnalog* p_positionSelector,
                    WsDsAnalog* p_delaySelector,
                    WsControllerButton* p_lockInSwitch,
                    WsDriverStationLED* p_lockInLed);

    void initializeAutonomousMgr(void);

    ~WsAutonomousMgr();
    void assignDriveBase(WsDriveBaseCrabSingle* p_driveBase);
    void assignAppendages( WsKicker* p_kicker, WsAccumulator* p_accumulator);
    void assignPresetWheelButton(WsControllerButton* p_button);
    UINT8 getProgNum(void);
    void getProgName(char* p_name);
    bool getLockState(void);
    StartingPositionT getPosition(void);
    float getStartDelay(void);
    void processLockin(void );
    void beginAutonomous(void );
    bool run(void );
protected:
    WsDsAnalog* ap_progNumSelectorDs;     /*!< The OI switch to select program number */
    WsDsAnalog* ap_positionSelectorDs;    /*!< The OI switch to select starting position */
    WsDsAnalog* ap_delaySelectorDs;    /*!< The OI switch to select starting delay */
    WsControllerAxis* ap_progNumSelectorAxis;   /*!< The OI Axis to select program number */
    WsControllerAxis* ap_positionSelectorAxis;  /*!< The OI Axis to select starting position */
    WsControllerAxis* ap_delaySelectorAxis;  /*!< The OI Axis to select starting delay */
    WsControllerButton* ap_lockInSwitch;  /*!< The OI switch to lock in autonomous*/
    WsDriverStationLED* ap_lockInLed;     /*!< The OI LED used to indicate autonomous state */
    WsDriveBaseCrabSingle* ap_driveBase;  /*!< The drive base to control */
    WsAutoProgramBase* ap_program;        /*!< The program object to interact with */
    WsKicker* ap_kicker;                  /*!< The kicker object to interact with */
    WsAccumulator* ap_accumulator;        /*!< The accumulator object to interact with */
    WsControllerButton* ap_presetWheelButton; /*!< Pressing this button when autonomous is started just points the wheels */

    UINT8 a_progNum;                      /*!< The program number to run */
    StartingPositionT a_position;         /*!< The position to run from */
    WsAutoProgramBase::StartDelayT a_delay;                        /*!< The delay to start with */
    UINT8 a_tempProgNum;                  /*!< An internal program number that can be manipulated before lockin*/
    StartingPositionT a_tempPosition;     /*!< An internal position that can be manipulated before lockin */
    WsAutoProgramBase::StartDelayT a_tempDelay;                    /*!< An internal delay that can be manipulated before lockin*/
    bool a_presetWheels;
    bool a_lockedIn;                      /*!< A flag for whether we're locked in or not */
    bool a_hasRun;                        /*!< A flag for whether autonomous has run (used to protect against running twice without unlocking) */

    char a_progName[PROG_NAME_LEN];       /*!< The program name that will be run */

    WsDashboard* ap_dashboard;            /*!< The dashboard to interact with */
};

#endif  //_WSAUTONOMOUSMGR_H
