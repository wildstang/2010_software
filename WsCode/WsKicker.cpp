//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsKicker.cpp
//  @ Date : 1/27/2010
//  @ Author : 
//
//


#include "WsKicker.h"
#include "WsSolenoid.h"
#include "WsKickerRange.h"
#include "WsKickerLoft.h"
#include "WsKickerTensioner.h"
#include "WsKickerLatch.h"
#include "DigitalInput.h"

//#define KICK_STATE_MACHINE_PRINTS

WsKicker::WsKicker(WsSolenoid *p_range, WsSolenoid *p_loft,
        WsSolenoid *p_tension, WsSolenoid *p_latch)
{
    a_enabled = true;
    ap_kickerRange = new WsKickerRange(p_range);
    ap_kickerLoft = new WsKickerLoft(p_loft);
    ap_kickerTensioner = new WsKickerTensioner(p_tension);
    ap_kickerLatch = new WsKickerLatch(p_latch);
    ap_ballPossessedLimit = NULL;

    a_state = KICKER_STATE_INIT;
    a_statePrev = KICKER_STATE_UNINIT;
    a_commandPrev = KICKER_CMD_NONE;

    a_pauseTimer.Start();
}

WsKicker::~WsKicker()
{
    delete ap_kickerRange;
    delete ap_kickerLoft;
    delete ap_kickerTensioner;
    delete ap_kickerLatch;
}

void WsKicker::assignKickerSensors(DigitalInput* p_ballPossessedLimit)
{
    ap_ballPossessedLimit = p_ballPossessedLimit;
}

bool WsKicker::isBallPossessed(void)
{
    bool ret = false;

    if(ap_ballPossessedLimit != NULL)
    {
        ret = ap_ballPossessedLimit->Get();
    }

    return ret;
}

bool WsKicker::isKicking(void)
{
    bool ret = false;

    if((a_state == KICKER_STATE_ADJUST_LOFT) ||
       (a_state == KICKER_STATE_SHOOT_NEAR) ||
       (a_state == KICKER_STATE_SHOOT_FAR) ||
       (a_state == KICKER_STATE_PREP_TRIGGER) ||
       (a_state == KICKER_STATE_BABY_KICK) ||
       (a_state == KICKER_STATE_ADJUST_LOFT_BABY))
    {
        ret = true;
    }

    return ret;
}

bool WsKicker::isStowed(void)
{
    bool ret = false;

    if(a_state == KICKER_STATE_STOW)
    {
        ret = true;
    }

    return ret;
}

void WsKicker::setCommand(WsKickerCommandT command)
{
    static bool s_periodPassed = false;
    static WsKickerRange::WsKickerRangeT s_kickerRange = WsKickerRange::KICKER_RANGE_NONE;
    WsKickerStateT nextState = a_state;

    if (a_enabled == true)
    {
#ifdef KICK_STATE_MACHINE_PRINTS
        printf("cmd %d state %d p_state %d ", command, a_state, a_statePrev);
#endif
        switch(a_state)
        {
            case KICKER_STATE_INIT:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_INIT  ");
#endif
                // Initialize then move immediately to far kick (default)
                ap_kickerRange->resetState();
                ap_kickerLoft->resetState();
                ap_kickerTensioner->resetState();
                ap_kickerLatch->resetState();
                s_kickerRange = ap_kickerRange->getRange();

                nextState = KICKER_STATE_SET_NEAR_KICK;
                break;

            case KICKER_STATE_STOW:
            case KICKER_STATE_SET_FAR_KICK:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_STOW/KICKER_STATE_FAR_KICK  ");
#endif
                if(a_state != a_statePrev)
                {
                    ap_kickerRange->setRange(WsKickerRange::KICKER_RANGE_FAR);
                    ap_kickerTensioner->setTension(
                        WsKickerTensioner::KICKER_TENSION_UP);
                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_STOW))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    if(command == KICKER_CMD_SET_RANGE_NEAR)
                    {
                        s_kickerRange = WsKickerRange::KICKER_RANGE_NEAR;
                        nextState = KICKER_STATE_SET_NEAR_KICK;
                    }
                    else if(command == KICKER_CMD_PREPARE_TO_KICK)
                    {
                        nextState = KICKER_STATE_LOAD_KICKER_FAR;
                    }
                    else if(command == KICKER_CMD_KICK_BABY_LOW)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT_BABY;
                    }
                    else if(command == KICKER_CMD_KICK_BABY_HIGH)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT_BABY;
                    }
                }

                break;
            case KICKER_STATE_LOAD_KICKER_NEAR:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_KICKER_NEAR  ");
#endif
                if(a_state != a_statePrev)
                {
                    ap_kickerRange->setRange(WsKickerRange::KICKER_RANGE_NEAR);
                    ap_kickerTensioner->setTension(
                        WsKickerTensioner::KICKER_TENSION_DOWN);
                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_LOAD_NEAR))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    if(command == KICKER_CMD_SET_RANGE_FAR)
                    {
                        s_kickerRange = WsKickerRange::KICKER_RANGE_FAR;
                        nextState = KICKER_STATE_LOAD_KICKER_FAR;
                    }
                    else if(command == KICKER_CMD_STOW)
                    {
                        nextState = KICKER_STATE_STOW;
                    }
                    else if(command == KICKER_CMD_KICK_LOW)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT;
                    }
                    else if(command == KICKER_CMD_KICK_HIGH)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT;
                    }
                }

                break;
            case KICKER_STATE_LOAD_KICKER_FAR:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_LOAD_KICKER_FAR  ");
#endif
                if(a_state != a_statePrev)
                {
                    ap_kickerRange->setRange(WsKickerRange::KICKER_RANGE_FAR);
                    ap_kickerTensioner->setTension(
                        WsKickerTensioner::KICKER_TENSION_DOWN);
                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_statePrev != KICKER_STATE_LOAD_KICKER_NEAR)
                {
                    if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_LOAD_FAR))
                    {
                        s_periodPassed = true;
                    }
                }
                else
                {
                    if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_LOAD_FAR_QUICK))
                    {
                        s_periodPassed = true;
                    }
                }

                if (s_periodPassed)
                {
                    if(command == KICKER_CMD_SET_RANGE_NEAR)
                    {
                        s_kickerRange = WsKickerRange::KICKER_RANGE_NEAR;
                        nextState = KICKER_STATE_LOAD_KICKER_NEAR;
                    }
                    else if(command == KICKER_CMD_STOW)
                    {
                        nextState = KICKER_STATE_STOW;
                    }
                    else if(command == KICKER_CMD_KICK_LOW)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT;
                    }
                    else if(command == KICKER_CMD_KICK_HIGH)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT;
                    }
                }
                break;
            case KICKER_STATE_ADJUST_LOFT:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_ADJUST_LOFT  ");
#endif
                if(a_state != a_statePrev)
                {
                    if(a_statePrev == KICKER_STATE_LOAD_KICKER_NEAR)
                    {
                        a_desiredNextState = KICKER_STATE_SHOOT_NEAR;
                    }
                    else
                    {
                        a_desiredNextState = KICKER_STATE_SHOOT_FAR;
                    }

                    if (a_commandPrev == KICKER_CMD_KICK_HIGH)
                    {
                        if (ap_kickerLoft->getLoft() == WsKickerLoft::KICKER_LOFT_HIGH)
                        {
                            // no need to pause, transition immediately
                            nextState = a_desiredNextState;
                        }
                        ap_kickerLoft->setLoft(WsKickerLoft::KICKER_LOFT_HIGH);
                    }
                    else
                    {
                        if (ap_kickerLoft->getLoft() == WsKickerLoft::KICKER_LOFT_LOW)
                        {
                            // no need to pause, transition immediately
                            nextState = a_desiredNextState;
                        }
                        ap_kickerLoft->setLoft(WsKickerLoft::KICKER_LOFT_LOW);
                    }

                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_ADJUST_LOFT))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    nextState = a_desiredNextState;
                }

                break;
            case KICKER_STATE_SHOOT_NEAR:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_SHOOT_NEAR  ");
#endif

                if(a_state != a_statePrev)
                {
                    ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_RELEASE);
                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_SHOOT_NEAR))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_HOLD);
                    nextState = KICKER_STATE_PREP_TRIGGER;
                }

                break;
            case KICKER_STATE_SHOOT_FAR:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_SHOOT_FAR  ");
#endif
                if(a_state != a_statePrev)
                {
                    ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_RELEASE);
                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_SHOOT_FAR))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_HOLD);
                    nextState = KICKER_STATE_PREP_TRIGGER;
                }

                break;
            case KICKER_STATE_PREP_TRIGGER:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_PREP_TRIGGER  ");
#endif
                if(a_state != a_statePrev)
                {
                    if (ap_kickerRange->getRange() ==
                        WsKickerRange::KICKER_RANGE_NEAR)
                    {
                        // no need to pause, transition immediately
                        nextState = KICKER_STATE_LATCH_KICKER;
                    }
                    ap_kickerRange->setRange(WsKickerRange::KICKER_RANGE_NEAR);
                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_PREP_TRIGGER))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    nextState = KICKER_STATE_LATCH_KICKER;
                }

                break;
            case KICKER_STATE_SET_NEAR_KICK:
            case KICKER_STATE_LATCH_KICKER:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_SET_NEAR_KICKER/KICKER_STATE_LATCH_KICKER  ");
#endif
                if(a_state != a_statePrev)
                {
                    ap_kickerRange->setRange(WsKickerRange::KICKER_RANGE_NEAR);
                    ap_kickerTensioner->setTension(
                        WsKickerTensioner::KICKER_TENSION_UP);

                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_SET_NEAR_KICKER) ||
                   a_statePrev == KICKER_STATE_INIT)
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    if(command == KICKER_CMD_PREPARE_TO_KICK)
                    {
                        nextState = KICKER_STATE_LOAD_KICKER_NEAR;
                    }
                    else if((command == KICKER_CMD_SET_RANGE_FAR) ||
                       (s_kickerRange == WsKickerRange::KICKER_RANGE_FAR))
                    {
                        s_kickerRange = WsKickerRange::KICKER_RANGE_FAR;
                        nextState = KICKER_STATE_SET_FAR_KICK;
                    }
                    else if(command == KICKER_CMD_STOW)
                    {
                        nextState = KICKER_STATE_STOW;
                    }
                    else if(command == KICKER_CMD_KICK_BABY_LOW)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT_BABY;
                    }
                    else if(command == KICKER_CMD_KICK_BABY_HIGH)
                    {
                        nextState = KICKER_STATE_ADJUST_LOFT_BABY;
                    }
                }

                break;
            case KICKER_STATE_BABY_KICK:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_BABY_KICK  ");
#endif
                if(a_state != a_statePrev)
                {
                    ap_kickerTensioner->setTension(WsKickerTensioner::KICKER_TENSION_DOWN);
                    ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_RELEASE);
                    //ap_kickerLoft->setLoft(WsKickerLoft::KICKER_LOFT_LOW);

                    a_pauseTimer.Reset();
                    s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_BABY_KICK))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_HOLD);

                    if (ap_kickerRange->getRange() ==
                        WsKickerRange::KICKER_RANGE_NEAR)
                    {
                        nextState = KICKER_STATE_SET_NEAR_KICK;
                    }
                    else
                    {
                        nextState = KICKER_STATE_SET_FAR_KICK;
                    }
                }

                break;
            case KICKER_STATE_ADJUST_LOFT_BABY:
#ifdef KICK_STATE_MACHINE_PRINTS
                printf("KICKER_STATE_ADJUST_LOFT_BABY  ");
#endif
                if(a_state != a_statePrev)
                {
                  a_desiredNextState = KICKER_STATE_BABY_KICK;

                  if (a_commandPrev == KICKER_CMD_KICK_BABY_HIGH)
                  {
                    if (ap_kickerLoft->getLoft() == WsKickerLoft::KICKER_LOFT_HIGH)
                    {
                      // no need to pause, transition immediately
                      nextState = a_desiredNextState;
                    }
                    ap_kickerLoft->setLoft(WsKickerLoft::KICKER_LOFT_HIGH);
                  }
                  else
                  {
                    if (ap_kickerLoft->getLoft() == WsKickerLoft::KICKER_LOFT_LOW)
                    {
                      // no need to pause, transition immediately
                      nextState = a_desiredNextState;
                    }
                    ap_kickerLoft->setLoft(WsKickerLoft::KICKER_LOFT_LOW);
                  }

                  a_pauseTimer.Reset();
                  s_periodPassed = false;
                }

                // Block transitions until time is up
                if(a_pauseTimer.HasPeriodPassed(KICKER_PAUSE_ADJUST_LOFT))
                {
                    s_periodPassed = true;
                }

                if (s_periodPassed)
                {
                    nextState = a_desiredNextState;
                }

                break;
            default:
                a_state = KICKER_STATE_INIT;
                break;
        }
    }
    else
    {
        ap_kickerRange->setRange(WsKickerRange::KICKER_RANGE_NONE);
        ap_kickerLoft->setLoft(WsKickerLoft::KICKER_LOFT_NONE);
        ap_kickerTensioner->setTension(WsKickerTensioner::KICKER_TENSION_NONE);
        ap_kickerLatch->setState(WsKickerLatch::KICKER_LATCH_NONE);
    }

    a_commandPrev = command;
    a_statePrev = a_state;
    a_state = nextState;

#ifdef KICK_STATE_MACHINE_PRINTS
    printf("nxt %d tmr %0.01f %d", nextState, a_pauseTimer.Get(), s_periodPassed);
    printf("\n");
#endif
}

void WsKicker::enable(bool enabled)
{
    a_enabled = enabled;
}

void WsKicker::resetState(void )
{
    a_state = KICKER_STATE_INIT;
}

WsKicker::WsKickerStateT WsKicker::getState(void )
{
    return a_state;
}

bool WsKicker::getEnabled(void)
{
    return a_enabled;
}

WsKickerRange::WsKickerRangeT WsKicker::getKickerRange(void)
{
    WsKickerRange::WsKickerRangeT range = WsKickerRange::KICKER_RANGE_NONE;
    if(ap_kickerRange != NULL)
    {
        range = ap_kickerRange->getRange();
    }

    return range;
}

WsKickerLoft::WsKickerLoftT WsKicker::getKickerLoft(void)
{
    WsKickerLoft::WsKickerLoftT loft = WsKickerLoft::KICKER_LOFT_NONE;
    if(ap_kickerLoft != NULL)
    {
        loft = ap_kickerLoft->getLoft();
    }

    return loft;
}

WsKickerTensioner::WsKickerTensionT WsKicker::getKickerTension(void)
{
    WsKickerTensioner::WsKickerTensionT tension = WsKickerTensioner::KICKER_TENSION_NONE;
    if(ap_kickerTensioner != NULL)
    {
        tension = ap_kickerTensioner->getTension();
    }

    return tension;
}

WsKickerLatch::WsKickerLatchStateT WsKicker::getKickerLatch(void)
{
    WsKickerLatch::WsKickerLatchStateT latch = WsKickerLatch::KICKER_LATCH_NONE;
    if(ap_kickerLatch != NULL)
    {
        latch = ap_kickerLatch->getState();
    }

    return latch;
}

WsKicker::WsKickerStateT WsKicker::getKickerState(void)
{
    return a_state;
}

