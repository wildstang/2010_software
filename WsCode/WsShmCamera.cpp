//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsShmCamera.cpp
//  @ Date : 1/18/2010
//  @ Author : 
//
//


#include "WsShmCamera.h"
#include "WsVisionTask.h"
#include <semLib.h>
using namespace std;

WsShmCamera::WsShmCamera()
{
  targetFound = false;
  targetHeading = 0;
}

WsShmCamera::~WsShmCamera()
{

}

/* copy data from shared memory to object attribute a_targets */
void WsShmCamera::findCandidates(void )
{
  int idx;
  VisionDataT *candidate = NULL;
  return;

  /* remove the previously found targets */
  clearTargets();

  /* grab the semaphore & copy the data */
  semTake(g_visionSemaphore, WAIT_FOREVER);

  targetFound = g_visionData.foundTarget;
  targetHeading = g_visionData.targetHeading;

  for (idx = 0; idx < g_visionData.numCandidates; idx++)
  {
    candidate = &g_visionData.candidateData[idx];

    WsVisionTarget target(candidate->majorRadius, candidate->minorRadius,
        candidate->rawScore, candidate->xPos, candidate->yPos,
        candidate->score, candidate->rotation, candidate->xMax,
        candidate->bothFound);
    a_targets.push_back(target);
  }

  semGive(g_visionSemaphore);
}

bool WsShmCamera::isTargetFound(void )
{
  return targetFound;
}

double WsShmCamera::getTargetHeading(void )
{
  return targetHeading;
}

int WsShmCamera::getNumCandidates(void )
{
  return a_targets.size();
}

bool WsShmCamera::getCandidateInfo(unsigned int idx, WsVisionTarget &target)
{
  if (idx < a_targets.size())
  {
    target.copyFrom(&a_targets[idx]);
    return true;
  }
  else
  {
    return false;
  }
}

void WsShmCamera::getAllCandidates(std::vector<WsVisionTarget>& targets)
{
    targets = a_targets;
}

