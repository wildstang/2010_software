//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutoSixStepBase.cpp
//  @ Date : 3/12/2009
//  @ Author : 
//
//


#include "Timer.h"
#include "WsAutoNStepBase.h"
#include "WsDriveBaseCrabSingle.h"
#include "WsDriveVector.h"
#include "WsDashboard.h"
#include "WsKickerRange.h"
#include "WsKickerLoft.h"
#include "WsAccumulator.h"
#include "WsDriveVector.h"

//Static function
float WsAutoNStepBase::convertDelay(StartDelayT delay)
{
  float delaySec = 0;
  switch(delay)
  {
    case DELAY_NONE:
      delaySec = 0;
      break;
    case DELAY_1:
      delaySec = 2;
      break;
    case DELAY_2:
      delaySec = 4;
      break;
    default:
      delaySec = 0;
      break;
  }
  return delaySec;
}

/**
* Constructs a WsAutoNStepBase.  Initializes the programe state.
*/
WsAutoNStepBase::WsAutoNStepBase()
{
    a_progState = AUTO_STATE_INIT;

    ap_dashboard = WsDashboard::getInstance();
}

/**
* Destructs a WsAccumulator
*/
WsAutoNStepBase::~WsAutoNStepBase()
{
}

/**
* Initializes program parameters.  This includes initializing attributes for the init and done state as well ans
* initializing the command list to neutral values
*/
void WsAutoNStepBase::initParams(void)
{
    int i;

    // Attributes for init
    a_initAccumState = WsAccumulator::ACCUM_OFF;

    // Attributes for init delay
    a_initDelay = convertDelay(a_startDelay);

    // Attributes for done
    a_doneCrabAngle = 0;
    a_doneAccumState = WsAccumulator::ACCUM_OFF;

    // Initialize all steps
    for(i = 0; i < MAX_STEPS; i++)
    {
        a_cmdList[i].driveType = AUTO_DRIVE_TIME;
        a_cmdList[i].crabEnable = true;
        a_cmdList[i].crabAngle = a_doneCrabAngle;
        a_cmdList[i].driveVector.a_direction = 0;
        a_cmdList[i].driveVector.a_speed = 0;
        a_cmdList[i].driveTimeout = 0;
        a_cmdList[i].driveEncoderDist = 0;
        a_cmdList[i].driveEncoderLoc = WsDriveBase::ENC_LOC_L;
        a_cmdList[i].accumState = a_doneAccumState;
        a_cmdList[i].kickerCmd = AUTO_KICKER_CMD_NONE;
        a_cmdList[i].kickerRange = WsKickerRange::KICKER_RANGE_NEAR;
        a_cmdList[i].kickerLoft = WsKickerLoft::KICKER_LOFT_LOW;
        a_cmdList[i].distancePid = NULL;
    }


    a_encoderToRevCmd.driveType = AUTO_DRIVE_TIME;
    a_encoderToRevCmd.crabEnable = true;
    a_encoderToRevCmd.crabAngle = a_doneCrabAngle;
    a_encoderToRevCmd.driveVector.a_direction = 0;
    a_encoderToRevCmd.driveVector.a_speed = 0;
    a_encoderToRevCmd.driveTimeout = 15;
    a_encoderToRevCmd.driveEncoderDist = 0;
    a_encoderToRevCmd.driveEncoderLoc = WsDriveBase::ENC_LOC_R;
    a_encoderToRevCmd.accumState = a_doneAccumState;
    a_encoderToRevCmd.kickerCmd = AUTO_KICKER_CMD_NONE;
    a_encoderToRevCmd.kickerRange = WsKickerRange::KICKER_RANGE_NEAR;
    a_encoderToRevCmd.kickerLoft = WsKickerLoft::KICKER_LOFT_LOW;

    a_overallEncTimeout = 0;
    a_overallEncLoc = WsDriveBase::ENC_LOC_R;

    a_expectedNumKicks = DEFAULT_NUM_KICKS;

    a_currentCmd = 0;
    a_cmdIdx = 0;
}

/**
* Adds the command passed in to the command list if there is room.
* Note that the command is stored in the next available slot, so when calling multiple times, be careful with the order the calls.
* If there is no room left in the command list (determined by MAX_STEPS), then the command is discarded
* @param step The WsAutoNStepCmdT to add to the command list
*/
void WsAutoNStepBase::addStep(const WsAutoNStepCmdT& step)
{
    if(a_cmdIdx < MAX_STEPS)
    {
        a_cmdList[a_cmdIdx].driveType = step.driveType;
        a_cmdList[a_cmdIdx].crabEnable = step.crabEnable;
        a_cmdList[a_cmdIdx].crabAngle = step.crabAngle;
        a_cmdList[a_cmdIdx].driveVector.a_speed = step.driveVector.a_speed;
        a_cmdList[a_cmdIdx].driveVector.a_direction = step.driveVector.a_direction;
        a_cmdList[a_cmdIdx].driveTimeout = step.driveTimeout;
        a_cmdList[a_cmdIdx].driveEncoderDist = step.driveEncoderDist;
        a_cmdList[a_cmdIdx].driveEncoderLoc = step.driveEncoderLoc;
        a_cmdList[a_cmdIdx].distancePid = step.distancePid;
        a_cmdList[a_cmdIdx].accumState = step.accumState;
        a_cmdList[a_cmdIdx].kickerCmd = step.kickerCmd;
        a_cmdList[a_cmdIdx].kickerRange = step.kickerRange;
        a_cmdList[a_cmdIdx].kickerLoft = step.kickerLoft;

        a_cmdIdx++;
    }
}

/**
* The main entry point for the autonomous program.  It is implemented as a state machine that does the following
* - AUTO_STATE_INIT
*   - Set all robot outputs to a neutral value
*   - Set the next state to AUTO_STATE_INIT_DELAY
* - AUTO_STATE_INIT_DELAY
*   - Set all robot outputs to a neutral value
*   - If the time specified by a_initDelay has passed since entering the state, move to AUTO_STATE_RUN_CMD
* - AUTO_STATE_RUN_CMD
*   - If there are more commands to be run
*      - Run the current command until it returns that it is done.  When that happens, the next command is chosen
*   - If there are no more commands to be run
*      - Set the program state to AUTO_STATE_DONE
* - AUTO_STATE_DONE
*   - Set all robot outputs to a neutral value
*   - Return that the program is done
*
* @returns A boolean value representing whether or not the program is done
*/
bool WsAutoNStepBase::run(void )
{
    bool done = false;
    double time = 0;
    int i;
    static bool retAccum = false;
    static bool retDrive = false;
    static bool retKicker = false;
    static bool firstTime = true;
    static WsEncoder* absEnc = NULL;
    WsAutoKickerCmd cmd;
    WsDriveVector stayPutVector(0, 0);
    INT32 absEncCount = 0;
    static bool encoderTimeout = false;
    static bool hasJustKickedPrev = false;
    bool hasJustKicked = false;
    WsAccumulator::WsBarStateT barState = WsAccumulator::BAR_DOWN;
    WsKickerRange::WsKickerRangeT nextRange = WsKickerRange::KICKER_RANGE_NEAR;
 
    bool isLastKick = (a_numKicksPerformed == a_expectedNumKicks - 1);

    switch(a_progState)
    {
        case AUTO_STATE_INIT:

            printf("N-INIT ");
            turnOffDriveBase();
            turnOffAppendages();
            setAccumState(a_initAccumState, WsAccumulator::BAR_DOWN);
            a_numKicksPerformed = 0;

            if(a_cmdIdx > 0)
            {
              if(a_presetWheels == true)
              {
                for(i = 0; i < MAX_STEPS; i++)
                {
                  // Grab the crab angle for the first step and assign to
                  // all steps.  Default everything else to a neutral state
                  a_cmdList[i].driveType = AUTO_DRIVE_TIME;
                  a_cmdList[i].crabEnable = a_cmdList[0].crabEnable;
                  a_cmdList[i].crabAngle = a_cmdList[0].crabAngle;
                  a_cmdList[i].driveVector.a_speed = 0;
                  a_cmdList[i].driveVector.a_direction = 0;
                  a_cmdList[i].driveTimeout = 2;
                  a_cmdList[i].driveEncoderDist = 0;
                  a_cmdList[i].accumState = WsAccumulator::ACCUM_OFF;
                  a_cmdList[i].kickerCmd = AUTO_KICKER_CMD_NONE;
                  a_cmdList[i].kickerRange = WsKickerRange::KICKER_RANGE_NEAR;
                  a_cmdList[i].kickerLoft = WsKickerLoft::KICKER_LOFT_LOW;
                }
              }
              else
              {
                for(i = a_cmdIdx; i < MAX_STEPS; i++)
                {
                  a_cmdList[i].crabEnable = a_cmdList[i - 1].crabEnable;
                  a_cmdList[i].crabAngle = a_cmdList[i - 1].crabAngle;
                }
              }
            }

            a_progState = AUTO_STATE_INIT_DELAY;
            retAccum = false;
            retDrive = false;
            retKicker = false;
            firstTime = true;
            encoderTimeout = false;

            if(a_overallEncTimeout != 0)
            {
                absEnc = ap_driveBase->getEncoder(a_overallEncLoc);
                absEnc->Reset();
                absEnc->Start();
            }
            else
            {
                absEnc = NULL;
            }

            break;
        case AUTO_STATE_INIT_DELAY:
            printf("N-INITD ");
            turnOffDriveBase();
            turnOffAppendages();
            setAccumState(a_initAccumState, WsAccumulator::BAR_DOWN);

            if (delay(a_initDelay, &time) == true)
            {
                a_progState = AUTO_STATE_RUN_CMD;
                a_currentCmd = 0;
            }
            //printf("DELAY %3.3f (%3.3f)\n", time, a_initDelay);
            break;
        case AUTO_STATE_RUN_CMD:
            printf("N-RUN(%d) ", a_currentCmd);
            if(a_currentCmd < MAX_STEPS)
            {

                if(absEnc != NULL)
                {
                    absEncCount = absEnc->getAbsCount();

                    if(((a_overallEncTimeout > 0) && (absEncCount >= a_overallEncTimeout)) ||
                       ((a_overallEncTimeout < 0) && (absEncCount <= a_overallEncTimeout)))
                    {
                        encoderTimeout = true;
                    }
                }

                setCrabEnableState(a_cmdList[a_currentCmd].crabEnable);

                if(encoderTimeout == false ||
                   a_numKicksPerformed >= a_expectedNumKicks)
                {
                    printf("RUN STATE %d ENC %d ", a_currentCmd, absEncCount);

                    if(retDrive == false)
                    {
                        switch(a_cmdList[a_currentCmd].driveType)
                        {
                            case AUTO_DRIVE_TIME:
                                printf("DBT ");
                                retDrive = driveByTime(&a_cmdList[a_currentCmd].driveVector,
                                        a_cmdList[a_currentCmd].crabAngle,
                                        a_cmdList[a_currentCmd].driveTimeout,
                                        &time);
                                break;
                            case AUTO_DRIVE_ENCODER:
                                printf("DBE ");
                                retDrive = driveByEncoder(&a_cmdList[a_currentCmd].driveVector,
                                        a_cmdList[a_currentCmd].crabAngle,
                                        a_cmdList[a_currentCmd].driveEncoderLoc,
                                        a_cmdList[a_currentCmd].driveEncoderDist,
                                        a_cmdList[a_currentCmd].driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            case AUTO_DRIVE_DIST_PID:
                                printf("DPID ");
                                retDrive = driveByDistancePid(&a_cmdList[a_currentCmd].driveVector,
                                        a_cmdList[a_currentCmd].crabAngle,
                                        a_cmdList[a_currentCmd].driveEncoderLoc,
                                        a_cmdList[a_currentCmd].driveEncoderDist,
                                        a_cmdList[a_currentCmd].distancePid,
                                        a_cmdList[a_currentCmd].driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            case AUTO_DRIVE_UNTIL_PRESS:
                                printf("DUP ");
                                retDrive = driveUntilPress(&a_cmdList[a_currentCmd].driveVector,
                                        a_cmdList[a_currentCmd].crabAngle,
                                        a_cmdList[a_currentCmd].driveTimeout,
                                        &time,
                                        firstTime);
                                break;
                            default:
                                printf("NONE<%d> ", a_cmdList[a_currentCmd].driveType);
                                retDrive = false;
                                break;
                        }
                    }
                    else
                    {
                        printf("HOLD ");
                        setDrive(&stayPutVector, a_cmdList[a_currentCmd].crabAngle);
                    }

                    cmd = a_cmdList[a_currentCmd].kickerCmd;

                    if(cmd == AUTO_KICKER_CMD_STOW)
                    {
                        retKicker = stowKicker();
                        barState = WsAccumulator::BAR_UP;
                    }
                    else if (cmd == AUTO_KICKER_CMD_LOAD)
                    {
                        retKicker = loadKicker(a_cmdList[a_currentCmd].kickerRange);
                        retKicker = true;
                    }
                    else if (cmd == AUTO_KICKER_CMD_KICK)
                    {
                        if(a_currentCmd < (MAX_STEPS - 1))
                        {
                          nextRange = a_cmdList[a_currentCmd + 1].kickerRange;
                        }
                        else
                        {
                          nextRange = a_cmdList[a_currentCmd].kickerRange;
                        }

                        retKicker = kick(a_cmdList[a_currentCmd].kickerLoft,
                                         isLastKick, nextRange);
                        if(retKicker == true)
                        {
                            retDrive = true;
                        }
                        hasJustKicked = true;
                    }
                    else if (cmd == AUTO_KICKER_CMD_BABY_KICK_LOW)
                    {
                        retKicker = babyKick(WsKickerLoft::KICKER_LOFT_LOW);
                        if(retKicker == true)
                        {
                            retDrive = true;
                        }
                        hasJustKicked = true;
                    }
                    else if (cmd == AUTO_KICKER_CMD_BABY_KICK_HIGH)
                    {
                        retKicker = babyKick(WsKickerLoft::KICKER_LOFT_HIGH);
                        if(retKicker == true)
                        {
                            retDrive = true;
                        }
                        hasJustKicked = true;
                    }
                    else if (cmd == AUTO_KICKER_CMD_SET_RANGE)
                    {
                        retKicker = setKickerRange(a_cmdList[a_currentCmd].kickerRange);
                    }
                    else
                    {
                        retKicker = true;
                    }

                    if(hasJustKicked == true && hasJustKickedPrev == false)
                    {
                        a_numKicksPerformed++;
                    }
                    hasJustKickedPrev = hasJustKicked;

                    retAccum = setAccumState(a_cmdList[a_currentCmd].accumState, barState);


                    firstTime = false;

                    if((retAccum == true) &&
                            (retDrive == true) &&
                            (retKicker == true))
                    {
                        a_currentCmd++;
                        retAccum = false;
                        retDrive = false;
                        retKicker = false;
                        firstTime = true;
                        hasJustKicked = false;
                        hasJustKickedPrev = false;
                    }
                }
                else
                {
                    printf("ENC TO %d ", a_currentCmd);
                    a_progState = AUTO_STATE_HANDLE_ENC_TO;
                    retAccum = false;
                    retDrive = false;
                    retKicker = false;
                    firstTime = true;
                }
            }
            else
            {
                a_progState = AUTO_STATE_DONE;
            }
            break;
        case AUTO_STATE_HANDLE_ENC_TO:
            printf("ENC-TO ");

            if(retDrive == false)
            {
                retDrive = driveByEncoder(&a_encoderToRevCmd.driveVector,
                        a_encoderToRevCmd.crabAngle,
                        a_encoderToRevCmd.driveEncoderLoc,
                        a_encoderToRevCmd.driveEncoderDist,
                        a_encoderToRevCmd.driveTimeout,
                        &time,
                        firstTime);
            }
            else
            {
                printf(" HOLD ");
                setDrive(&stayPutVector, a_encoderToRevCmd.crabAngle);
            }

            retAccum = setAccumState(a_encoderToRevCmd.accumState, WsAccumulator::BAR_DOWN);
            retKicker = kick(a_encoderToRevCmd.kickerLoft, false, WsKickerRange::KICKER_RANGE_NEAR);

            firstTime = false;

            break;
        case AUTO_STATE_DONE:
            printf("N-DONE ");
            setDrive(&stayPutVector, a_doneCrabAngle);
            turnOffAppendages();

            retAccum = setAccumState(a_doneAccumState, WsAccumulator::BAR_DOWN);

            done = true;
            break;
        default:
            a_progState = AUTO_STATE_DONE;
            break;
    }

    /*
    ap_dashboard->setValue(IDX_AUTO_PROGSTATE, (UINT32)a_progState);
    ap_dashboard->setValue(IDX_AUTO_DATA1, (float)time);
    ap_dashboard->setValue(IDX_AUTO_DATA2, (float)a_currentCmd);
    */
    printf("\n");

    return done;
}

