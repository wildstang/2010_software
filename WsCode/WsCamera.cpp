//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsCamera.cpp
//  @ Date : 1/18/2010
//  @ Author : 
//
//


#include "WsCamera.h"
#include "Timer.h"
#include <math.h>
using namespace std;

static EllipseDescriptor ellipseDescriptor = {
  3,    // minMajorRadius
  40,   // maxMajorRadius
  3,    // minMinorRadius
  40    // maxMinorRadius
};

static CurveOptions curveOptions = {
  IMAQ_NORMAL_IMAGE,  // extractionMode
  100,                // threshold
  IMAQ_FINE,          // filterSize
  25,                 // minLength
  15,                 // rowStepSize
  15,                 // columnStepSize
  10,                 // maxEndPointGap
  1,                  // onlyClosed
  0                   // subpixelAccuracy
};

static ShapeDetectionOptions shapeOptions = {
  IMAQ_GEOMETRIC_MATCH_SHIFT_INVARIANT,  // mode
  NULL,                                  // angle ranges
  0,                                     // num angle ranges
  0,                                     // scale range
  700                                    // minMatchScore
};

/**
 * Compare two targets.
 * Compare the score of two targets for the sort function in C++.
 * @param t1 the first WsVisionTarget
 * @param t2 the second WsVisionTarget
 * @returns (1, 0, or -1) for the scores of t1 > t2, t1 == t2, and t1 < t2
 */
int compareTargets(WsVisionTarget t1, WsVisionTarget t2)
{
  if (t1.a_score > t2.a_score) return 1;
  if (t1.a_score < t2.a_score) return -1;
  return 0;
}


WsCamera::WsCamera(AxisCamera *a)
{
  ap_camera = a;
  if(ap_camera != NULL)
  {
      ap_camera->WriteResolution(AxisCameraParams::kResolution_320x240);
      //ap_camera->WriteResolution(AxisCameraParams::kResolution_160x120);
      //ap_camera->WriteResolution(AxisCameraParams::kResolution_640x480);
      ap_camera->WriteBrightness(0);
      ap_camera->WriteExposureControl(AxisCameraParams::kExposure_Automatic);
      ap_camera->WriteExposurePriority(50);
      ap_camera->WriteCompression(20);
      Wait(3.0);
  }
  else
  {
    printf("!!! NULL CAMERA !!!\n");
  }
}

WsCamera::~WsCamera()
{

}

void WsCamera::findCandidates(void )
{
  Timer t;
  ColorImage *image = NULL;
  return;

  /* remove the previously found targets */
  clearTargets();

  /* wait until a new image is available */
  while (ap_camera->IsFreshImage() == false)
  {
    Wait(0.01);
  }

  image = ap_camera->GetImage();
  if (image != NULL)
  {
    printf("image ");
    t.Start();
    FindCircularTargets(image);
    printf("%f ", t.Get());
    delete image;
    image = NULL;
  }
  printf("\n");
}

bool WsCamera::isTargetFound(void )
{
  if ((a_targets.size() > 0) && (a_targets[0].a_bothFound == true))
  {
    return true;
  }
  else
  {
    return false;
  }
}

double WsCamera::getTargetHeading(void )
{
  if (isTargetFound() == true)
  {
    return a_targets[0].getHorizontalAngle();
  }
  else
  {
    return 0;
  }
}

int WsCamera::getNumCandidates(void )
{
  return a_targets.size();
}

bool WsCamera::getCandidateInfo(unsigned int idx, WsVisionTarget &target)
{
  if (idx < a_targets.size())
  {
    target.copyFrom(&a_targets[idx]);
    return true;
  }
  else
  {
    return false;
  }
}

void WsCamera::FindCircularTargets(ColorImage *image)
{
    return;
  MonoImage *luminancePlane = NULL;
  vector<EllipseMatch> *results = NULL;
  vector<WsVisionTarget> individualTargets;
  int width;
  int height;
  ROI *roi;

  if (image != NULL)
  {
    width = image->GetWidth();
    height = image->GetHeight();

    /* get the luminance plane only for the image to make the code
       insensitive to lighting conditions */
    luminancePlane = image->GetLuminancePlane();

    roi = imaqCreateROI();
    imaqAddRectContour(roi, imaqMakeRect(30, 0, 130, 320));

    results = luminancePlane->DetectEllipses(&ellipseDescriptor,
                                             &curveOptions, &shapeOptions,
                                             roi);
    imaqDispose(roi);
    delete luminancePlane;
    luminancePlane = NULL;

    printf("results %2d  ", results->size());
    if (results->size() == 0)
    {
      delete results;
      return;
    }

    /* create a list of targets corresponding to each ellipse found */
    for (unsigned i = 0; i < results->size(); i++)
    {
      WsVisionTarget target;
      EllipseMatch e = results->at(i);

      target.a_rawScore = e.score;
      target.a_score = (e.majorRadius * e.minorRadius) /
                       (1001 - e.score) /
                       (height * width) * 100;
      target.a_majorRadius = e.majorRadius / height;
      target.a_minorRadius = e.minorRadius / height;
      /* always divide by height so that x and y are same units */
      target.a_xPos = (2.0 * e.position.x - width) / height;
      target.a_yPos = (2.0 * e.position.y - height) / height;
      target.a_rotation = e.rotation;
      target.a_xMax = (double)width / height;
      target.a_bothFound = false;
      individualTargets.push_back(target);
    }
    delete results;

    /* sort the list of targets by score */
    sort(individualTargets.begin(), individualTargets.end(), compareTargets);

    /* go through each target found in descending score order and look
       for another target whose center is contained inside of this target
       Those concentric targets get a score which is the sum of both targets */
    while (individualTargets.size() > 0)
    {
      vector<WsVisionTarget>::iterator iter = individualTargets.begin();
      WsVisionTarget t1 = *iter++;
      for (; iter < individualTargets.end(); iter++)
      {
        WsVisionTarget t2 = *iter;

        // check if the two are concentric
        if ((fabs(t1.a_xPos - t2.a_xPos) < min(t1.a_minorRadius, t2.a_minorRadius)) &&
            (fabs(t1.a_yPos - t2.a_yPos) < min(t1.a_majorRadius, t2.a_majorRadius)))
        {
          /* create the information for the combined target
             (the 2 concentric ellipses) */
          //printf("found combined  ");
          t1.a_xPos = (t1.a_xPos + t2.a_xPos) / 2;
          t1.a_yPos = (t1.a_yPos + t2.a_yPos) / 2;
          t1.a_rawScore += t2.a_rawScore;
          t1.a_score += t2.a_score;
          t1.a_majorRadius = max(t1.a_majorRadius, t2.a_majorRadius);
          t1.a_minorRadius = max(t1.a_minorRadius, t2.a_minorRadius);
          t1.a_bothFound = true;
          individualTargets.erase(iter); /* loop needs to be an interator */
          break;
        }
      }
      individualTargets.erase(individualTargets.begin());
      a_targets.push_back(t1);
    }

    /* sort the combined targets so the highest scoring one is first */
    sort(a_targets.begin(), a_targets.end(), compareTargets);
    if(isTargetFound())
    {
        printf(" found %f (%f, %f) ", getTargetHeading(), a_targets[0].a_xPos, a_targets[0].a_yPos);
    }
    else
    {
        printf(" not found");
    }
  }
}

