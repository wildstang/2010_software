//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang 2010
//  @ File Name : WsPid.cpp
//  @ Date : 1/14/2009
//  @ Author :
//
//


#include "WsPid.h"



/**
 * Initializes the WsPid object. All parameters default to 0.
 */
WsPid::WsPid(float p, float i, float d, int epsilon)
{
    a_p = p;
    a_i = i;
    a_d = d;

    a_errorEpsilon = epsilon;
    a_desiredValue = 0; // Default to 0, set later by the user
    a_firstCycle = true;
    a_maxOutput = 1.0; // Default to full range
    a_errorIncrement = 1;

    a_cycleCount = 0;
    a_minCycleCount = 10; // Default
}

WsPid::~WsPid()
{
}

float WsPid::getP(void)
{
    return a_p;
}

float WsPid::getI(void)
{
    return a_i;
}

float WsPid::getD(void)
{
    return a_d;
}

int WsPid::getEpsilon(void)
{
    return a_errorEpsilon;
}


/**
 * Sets the Pid constants to new values.
 */
void WsPid::setConstants(float p, float i, float d)
{
    a_p = p;
    a_i = i;
    a_d = d;

}

/**
 * Sets the allowable error range away from the desired value.
 */
void WsPid::setErrorEpsilon(int epsilon)
{
    a_errorEpsilon = epsilon;
}

/**
 * Sets the maximum increment to the error sum used in the I component
 * calculation.
 * This defaults to 1 in the constructor, which has worked well for 1114 the
 * past few years.
 */
void WsPid::setErrorIncrement(int inc)
{
    a_errorIncrement = inc;
}

/**
 * Sets the desired value.
 */
void WsPid::setDesiredValue(int val)
{
    a_desiredValue = val;
}

/**
 * Gets the desired value.
 */
int WsPid::getDesiredValue(void)
{
    return a_desiredValue;
}

/**
 * Sets the ceiling for the output of the calculation.
 * This defaults to 1.0 (full output). Values should be between 0.0 and 1.0.
 */
void WsPid::setMaxOutput(float max)
{
    if(max >= 0.0 && max <= 1.0)
    {
        a_maxOutput = max;
    }
}

/**
 * Resets the error sum back to zero.
 */
void WsPid::resetErrorSum(void)
{
    a_errorSum = 0;
}

/**
 * Calculates the Pid output based on the current value.
 * Pid constants and desired value should be set before calling this
 * function.
 */
float WsPid::calcPid(int currentValue)
{
    // Initialize all components to 0.0 to start.
    float pVal = 0.0;
    float iVal = 0.0;
    float dVal = 0.0;

    // Don't apply D the first time through.
    if(a_firstCycle)
    {
        a_previousValue = currentValue;  // Effective velocity of 0
        a_firstCycle = false;
    }

    // Calculate P Component.
    int error = a_desiredValue - currentValue;
    pVal = a_p * (float)error;

    // Calculate I Component.
    // Error is positive and outside the epsilon band.
    if(error >= a_errorEpsilon)
    {
        // Check if epsilon was pushing in the wrong direction.
        if(a_errorSum < 0)
        {
            // If we are fighting away from the point, reset the error.
            a_errorSum = 0;
        }
        if(error < a_errorIncrement)
        {
            // If the error is smaller than the max increment amount, add it.
            a_errorSum += error;
        }
        else
        {
            // Otherwise, add the maximum increment per cycle.
            a_errorSum += a_errorIncrement;
        }
    }
    // Error is negative and outside the epsilon band.
    else if(error <= -a_errorEpsilon)
    {
        if(a_errorSum > 0)
        {
            // If we are fighting away from the point, reset the error.
            a_errorSum = 0;
        }
        // error is small than max contribution -> just subtract error amount
        if(error > -a_errorIncrement)
        {
            // If the error is smaller than the max increment amount, add it.
            a_errorSum += error; // Error is negative
        }
        else
        {
            // Otherwise, subtract the maximum increment per cycle.
            a_errorSum -= a_errorIncrement;
        }
    }
    // Error is inside the epsilon band.
    else
    {
        a_errorSum = 0;
    }
    iVal = a_i * (float)a_errorSum;

    // Calculate D Component.
    int velocity = currentValue - a_previousValue;
    dVal = a_d * (float)velocity;

    // Calculate and limit the ouput: Output = P + I - D
    float output = pVal + iVal - dVal;
    if(output > a_maxOutput)
    {
        output = a_maxOutput;
    }
    else if(output < -a_maxOutput)
    {
        output = -a_maxOutput;
    }

    // Save the current value for next cycle's D calculation.
    a_previousValue = currentValue;

    return output;
}

/**
 * Sets the minimum number of cycles the value must be in the epsilon range
 * before the system is considered stable.
 */
void WsPid::setMinDoneCycles(int n)
{
    a_minCycleCount = n;
}

/**
 * Returns true if the last input was within the epsilon range of the
 * destination value, and the system is stable.
 */
bool WsPid::isDone(void)
{
    if (a_previousValue <= a_desiredValue + a_errorEpsilon &&
        a_previousValue >= a_desiredValue - a_errorEpsilon &&
        !a_firstCycle)
    {
        if(a_cycleCount >= a_minCycleCount)
        {
            return true;
        }
        else
        {
            a_cycleCount++;
            return false;
        }
    }
    a_cycleCount = 0;
    return false;
}
