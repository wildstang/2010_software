//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang 2010
//  @ File Name : WsRobot2010.cpp
//  @ Date : 1/14/2009
//  @ Author : 
//
//

#include <taskLib.h>
#include <semLib.h>
#include <errno.h>

#include "WsRobot2010.h"
#include "Joystick.h"
#include "Gamepad.h"
#include "Jaguar.h"
#include "Victor.h"
#include "Servo.h"
#include "Solenoid.h"
#include "Compressor.h"
#include "Task.h"
#include "DriverStation.h"
#include "DriverStationLCD.h"
#include "DigitalInput.h"
#include "DigitalOutput.h"
#include "AnalogChannel.h"
#include "WsControllerAxis.h"
#include "WsControllerButton.h"
#include "WsControllerPolarStick.h"
#include "WsControllerStickyButton.h"
#include "WsControllerMultiStickyButton.h"
#include "WsControllerLongHoldButton.h"
#include "WsControllerAnalogButton.h"
#include "WsControllerButton.h"
#include "WsControlMethodCrab.h"
#include "WsMotorManager.h"
#include "WsEncoder.h"
#include "WsSc.h"
#include "WsRelay.h"
#include "WsSolenoid.h"
#include "WsDoubleSolenoid.h"
#include "WsPot.h"
#include "WsCrabController.h"
#include "WsDriveBaseCrabSingle.h"
#include "WsDashboard.h"
#include "WsLogger.h"
#include "WsCalibration.h"
#include "WsPid.h"
#include "LogServer/logtask.h"
#include "WsDsAnalog.h"
#include "WsAutonomousMgr.h"
#include "WsVisionTask.h"
#include "WsDriverStationLED.h"
#include "WsShmCamera.h"
#include "WsPidTuner.h"
#include "WsAccumulator.h"
#include "WsAppendageControl.h"
#include "WsKicker.h"
#include "WsHanger.h"
#include "WsTowerAlign.h"
#include "WsTowerFingers.h"

#define ENABLE_LOG_SERVER 0
#define ENABLE_VISION_TASK 1
#define ENABLE_DASHBOARD 1
#define ENABLE_PID_TUNING 0
#define OI_TEST 0

#if ENABLE_LOG_SERVER
Task g_logServerTask("LogServer", (FUNCPTR)log_task_main);
#endif

#if ENABLE_VISION_TASK
Task g_visionTask("WsVision", (FUNCPTR)vision_task_main);
#endif

void WsRobot2010::RobotInit(void )
{
    /* Called when the robot is first initialized; instantiate robot objects */
    GetWatchdog().SetExpiration(Watchdog::kDefaultWatchdogExpiration);
    printf("**********  Wildstang 2010 ***********\n");
    ap_dashboard = WsDashboard::getInstance(m_ds);
    ap_dsLcd = DriverStationLCD::GetInstance();
    ap_calib = WsCalibration::getInstance();
    a_calibrationMode = false;
    a_crabCalibrationOn = false;

    ap_dsLockInLed = new WsDriverStationLED(1);

#if ENABLE_LOG_SERVER
    g_logServerTask.Start();
    ap_logger = WsLogger::getInstance();
#else
    ap_logger = NULL;
#endif

    /********************
     * Inputs
     ********************/
    ap_driveGamepad = new Gamepad(1);
    ap_pidTunerGamepad = new Gamepad(2);
    ap_appendageGamepad = new Gamepad(3);
    ap_oiGamepad = new Gamepad(4);

    /***** Common controls on OI panel *****/
    //ap_calibrateEnableButton = new WsControllerButton(2);
    ap_calibrateEnableButton = new WsControllerButton(ap_oiGamepad, 4);
    ap_calibrateCrabPotLeftButton = new WsControllerButton(ap_driveGamepad, 1);
    ap_calibrateCrabPotMidButton = new WsControllerButton(ap_driveGamepad, 4);
    ap_calibrateCrabPotRightButton = new WsControllerButton(ap_driveGamepad, 3);

    ap_autoProgSelector = new WsControllerAxis(ap_oiGamepad, 1);
    ap_autoPositionSelector = new WsControllerAxis(ap_oiGamepad, 2);
    ap_autoLockinSwitch = new WsControllerButton(ap_oiGamepad, 3);
    ap_autoDelaySelector = new WsControllerAxis(ap_oiGamepad, 3);

    /***** Driver controls *****/
    ap_driveAxisX = new WsControllerAxis(ap_driveGamepad, 3);
    ap_driveAxisY = new WsControllerAxis(ap_driveGamepad, 4);
    ap_turboButton = new WsControllerButton(ap_driveGamepad, 7);
    ap_accumBarRaiseButton = new WsControllerButton(ap_driveGamepad, 5);
    ap_accumInButton = new WsControllerMultiStickyButton(ap_driveGamepad, 6, 8);
    //ap_accumInButton = new WsControllerButton(ap_driveGamepad, 6);
    //ap_accumOutButton = new WsControllerButton(ap_driveGamepad, 8);
    ap_driveStick = new WsControllerPolarStick(ap_driveAxisX, ap_driveAxisY);
    ap_crabReorientButton = new WsControllerMultiStickyButton(ap_driveGamepad,
        Gamepad::kDown, Gamepad::kUp);

#if TEST_VEL_PID
    ap_tempVelocityPidTestButton = new WsControllerButton(ap_driveGamepad, 10);
#endif

    ap_crabAxisX = new WsControllerAxis(ap_driveGamepad, 1);
    ap_crabAxisY = new WsControllerAxis(ap_driveGamepad, 2);
    ap_crabStick = new WsControllerPolarStick(ap_crabAxisX, ap_crabAxisY);

    /* OI */
    ap_crabDisableButton = new WsControllerButton(ap_oiGamepad, 1);
    ap_crabManualButton  = new WsControllerButton(ap_driveGamepad, 4);
    ap_crabManualSlowButton  = new WsControllerButton(ap_driveGamepad, 3);

    /***** Manipulator controls *****/
    ap_prepKickButton = new WsControllerButton(ap_appendageGamepad, 5);
    ap_stowKickerButton = new WsControllerButton(ap_appendageGamepad, 7);
    ap_kickHighButton = new WsControllerButton(ap_appendageGamepad, 6);
    ap_kickLowButton = new WsControllerButton(ap_appendageGamepad, 8);
    ap_kickBabyButton = new WsControllerButton(ap_appendageGamepad, 4);
    ap_kickBabyHighButton = new WsControllerButton(ap_appendageGamepad, 1);
    ap_kickRangeNearButton = new WsControllerButton(ap_appendageGamepad, 2);
    ap_kickRangeFarButton = new WsControllerButton(ap_appendageGamepad, 3);

    ap_releaseArmsButton = new WsControllerMultiStickyButton(ap_appendageGamepad, Gamepad::kUp, Gamepad::kDown);
    ap_releaseTowerAlignButton = new WsControllerLongHoldButton(ap_appendageGamepad, 9, 1.0);
    ap_toggleTowerFingersButton = new WsControllerStickyButton(ap_appendageGamepad, 10); // Maybe make this a long hold sticky??
    ap_winchSlowSafetyButton = new WsControllerButton(ap_appendageGamepad, Gamepad::kUp);
    ap_winchFullSafetyButton = new WsControllerButton(ap_appendageGamepad, Gamepad::kDown);
    ap_winchDriveAxis = new WsControllerAxis(ap_appendageGamepad, 4, true);

    ap_cameraUpButton = new WsControllerMultiStickyButton(ap_appendageGamepad, Gamepad::kUp, Gamepad::kDown);

    /* OI */
    ap_pneumaticsDisable = new WsControllerButton(ap_oiGamepad, 2);
    ap_swDisable = new WsControllerButton(ap_oiGamepad, 5);

    /***** Input Control Objects *****/
    ap_controlMethodCrab = new WsControlMethodCrab();
    ap_controlMethodCrab->assignCrabStick(ap_crabStick);
    ap_controlMethodCrab->assignCrabDisableButton(ap_crabDisableButton);
    ap_controlMethodCrab->assignCrabManualButton(ap_crabManualButton);
    ap_controlMethodCrab->assignCrabManualSlowButton(ap_crabManualSlowButton);
    //ap_controlMethodCrab->assignCrabReorientButton(ap_crabReorientButton);
    ap_controlMethodCrab->assignDriveStick(ap_driveStick);
    ap_controlMethodCrab->assignTurboButton(ap_turboButton, WsControlMethodArcade::TURBO_STYLE_ANTI);

    ap_appendageController = new WsAppendageControl();
    ap_appendageController->assignAccumButtons(ap_accumInButton,
                                               NULL,//ap_accumOutButton,
                                               ap_accumBarRaiseButton);
    ap_appendageController->assignKickerButtons(ap_prepKickButton,
        ap_stowKickerButton, ap_kickHighButton, ap_kickLowButton,
        ap_kickBabyButton, ap_kickBabyHighButton,
        ap_kickRangeNearButton, ap_kickRangeFarButton);
    ap_appendageController->assignHangerInputs(ap_releaseArmsButton,
                                               ap_releaseTowerAlignButton,
                                               ap_toggleTowerFingersButton,
                                               ap_winchSlowSafetyButton,
                                               ap_winchFullSafetyButton,
                                               ap_winchDriveAxis);

    /********************
     * Sensors
     ********************/
    ap_crabPot = new WsPot(1, 1);
    ap_camera = new WsShmCamera();
    ap_analogPressureSensor = new AnalogChannel(1, 2);
    //ap_encoderFL = new WsEncoder(12, 11);
    //ap_encoderBR = new WsEncoder(13, 14);
    ap_encoderFL = new WsEncoder(11, 12);
    ap_encoderBR = new WsEncoder(14, 13);

    // Calculated by wheel circumference / N ticks
    // Gives .2945 inches per tick for 64 for 6" wheel
    // Gives .1472 inches per tick for 128 for 6" wheel
    ap_encoderFL->SetDistancePerPulse(.1472);
    ap_encoderBR->SetDistancePerPulse(.1472);

    //ap_armLimit = new DigitalInput(1);
    ap_ballPossessedLimit = new DigitalInput(2);



    /********************
     * PID Controllers
     ********************/
    if (ap_calib->isCompetitionRobot())
    {
      //ap_crabPID = new WsPid(.05, .000, 0, 3);
      ap_crabPID = new WsPid(.06, .000, .007, 2);
      ap_crabAlignPID = new WsPid(.04, .000, 0, 0);
    }
    else
    {
      //ap_crabPID = new WsPid(.020, .020, 0, 3);
      ap_crabPID = new WsPid(.05, .000, 0, 3);
      ap_crabAlignPID = new WsPid(.01, .000, 0, 0);
    }
    ap_crabPID->setMinDoneCycles(10);

    ap_driveVelocityPID = new WsPid(.002, .001, .0008, 50);
    ap_driveVelocityPID->setMinDoneCycles(3);

    /********************
     * Outputs
     ********************/

    /***** Speed Controllers *****/
#if 0
    if (ap_calib->isOldRobot())
    {
        printf("---- OLD ----\n");
        ap_scDriveFL = new WsSc(WsSc::WS_SC_VICTOR, 3);
        ap_scDriveFR = new WsSc(WsSc::WS_SC_VICTOR, 1);
        ap_scDriveBL = new WsSc(WsSc::WS_SC_VICTOR, 4);
        ap_scDriveBR = new WsSc(WsSc::WS_SC_VICTOR, 2);
    }
    else
#endif
#if 0
    {
        printf("---- NEW ----\n");
        ap_scDriveFL = new WsSc(WsSc::WS_SC_VICTOR, 1);
        ap_scDriveFR = new WsSc(WsSc::WS_SC_VICTOR, 2);
        ap_scDriveBL = new WsSc(WsSc::WS_SC_VICTOR, 3);
        ap_scDriveBR = new WsSc(WsSc::WS_SC_VICTOR, 4);
    }
#endif
    ap_scDriveFL = new WsSc(WsSc::WS_SC_VICTOR, 3);
    ap_scDriveFR = new WsSc(WsSc::WS_SC_VICTOR, 1);
    ap_scDriveBL = new WsSc(WsSc::WS_SC_VICTOR, 4);
    ap_scDriveBR = new WsSc(WsSc::WS_SC_VICTOR, 2);

    ap_scCrabL   = new WsSc(WsSc::WS_SC_VICTOR, 5);
    ap_scCrabR   = new WsSc(WsSc::WS_SC_VICTOR, 6);
    ap_scAccumulator = new WsSc(WsSc::WS_SC_VICTOR, 7);
    //ap_scWinch = new WsSc(WsSc::WS_SC_VICTOR, 8);

    /***** Servos *****/
    //ap_servTowerAlign = new Servo(10);
    //ap_servTowerAlign = new Servo(9);
    ap_servCamera = new Servo(9);

    /***** Solenoids *****/
    ap_solAccumBar = new WsSolenoid(5);
    ap_solKickerRange = new WsSolenoid(2);
    ap_solKickerLoft = new WsSolenoid(4);
    ap_solKickerTension = new WsSolenoid(1);
    ap_solKickerLatch = new WsSolenoid(3);
    //ap_solWinchBrake = new WsSolenoid(8);
    //ap_solArmDeploy = new WsSolenoid(7);
    //ap_dsolTowerFingers = new WsDoubleSolenoid(5, 6);

    /***** Relays *****/

    /***** Compressor *****/
    ap_compressor = new Compressor(1, 1);
    ap_compressor->Start();

    ap_ballPossessLED = new DigitalOutput(3);

    /***** Robot Output Objects *****/
    ap_crabController = new WsCrabController(ap_scCrabL, ap_scCrabR, ap_crabPot);
    ap_crabController->assignPid(ap_crabPID);
    ap_crabController->assignAlignPid(ap_crabAlignPID);

    ap_driveBase = new WsDriveBaseCrabSingle(ap_scDriveFL, ap_scDriveBL,
                                             ap_scDriveFR, ap_scDriveBR,
                                             ap_crabController);
    ap_driveBase->assignEncoder(WsDriveBase::ENC_LOC_R, ap_encoderBR);
    ap_driveBase->assignEncoder(WsDriveBase::ENC_LOC_L, ap_encoderFL);


    ap_kicker = new WsKicker(ap_solKickerRange, ap_solKickerLoft,
                             ap_solKickerTension, ap_solKickerLatch);
    ap_kicker->assignKickerSensors(ap_ballPossessedLimit);

    ap_accumulator = new WsAccumulator(ap_scAccumulator);
    ap_accumulator->assignAccumulatorSensors(ap_ballPossessedLimit);

    ap_accumulator->assignBarSolenoid(ap_solAccumBar);

    /********************
     * Miscellenaeous
     ********************/
    /* Motor managers */
    ap_mmgrRobot = new WsMotorManager();
    ap_mmgrRobot->addOutput(ap_scDriveFL);
    ap_mmgrRobot->addOutput(ap_scDriveFR);
    ap_mmgrRobot->addOutput(ap_scDriveBL);
    ap_mmgrRobot->addOutput(ap_scDriveBR);
    ap_mmgrRobot->addOutput(ap_scCrabL);
    ap_mmgrRobot->addOutput(ap_scCrabR);

    ap_mmgrDriveBase = new WsMotorManager();
    ap_mmgrDriveBase->addOutput(ap_scDriveFL);
    ap_mmgrDriveBase->addOutput(ap_scDriveFR);
    ap_mmgrDriveBase->addOutput(ap_scDriveBL);
    ap_mmgrDriveBase->addOutput(ap_scDriveBR);
    ap_mmgrDriveBase->addOutput(ap_scCrabL);
    ap_mmgrDriveBase->addOutput(ap_scCrabR);

    /* PID Tuning */
    ap_tunePidButton = new WsControllerButton(ap_pidTunerGamepad, 2); // X
    ap_pidTuneParamSelectNextButton = new WsControllerButton(ap_pidTunerGamepad, Gamepad::kUpRight);
    //ap_pidTuneParamSelectPrevButton = new WsControllerButton(ap_pidTunerGamepad, Gamepad::kLeft);
    ap_pidTuneParamSelectPrevButton = new WsControllerButton(ap_pidTunerGamepad, Gamepad::kUpLeft);
    ap_pidTuneParamIncrButton = new WsControllerButton(ap_pidTunerGamepad, Gamepad::kDownRight);
    ap_pidTuneParamDecrButton = new WsControllerButton(ap_pidTunerGamepad, Gamepad::kDownLeft);
    ap_pidTuneRunStepTestButton = new WsControllerButton(ap_pidTunerGamepad, 4); // Triangle
    ap_pidTuneRunPidButton = new WsControllerButton(ap_pidTunerGamepad, 3); // Circle
    ap_pidTuneControlAxis = new WsControllerAxis(ap_pidTunerGamepad, 4);

    ap_resetEncodersButton = new WsControllerButton(ap_driveGamepad, 2);

    ap_crabPidTuner = new WsPidTuner();
    ap_crabPidTuner->assignTuneButton(ap_tunePidButton);
    ap_crabPidTuner->assignParamSelectButtons(ap_pidTuneParamSelectPrevButton,
                                              ap_pidTuneParamSelectNextButton);
    ap_crabPidTuner->assignParamModifyButtons(ap_pidTuneParamIncrButton,
                                              ap_pidTuneParamDecrButton);
    ap_crabPidTuner->assignRunStepTestButton(ap_pidTuneRunStepTestButton);
    ap_crabPidTuner->assignRunPidButton(ap_pidTuneRunPidButton);
    ap_crabPidTuner->assignControllerAxis(ap_pidTuneControlAxis);
    ap_crabPidTuner->assignTunableController(ap_crabController);

    /* Autonomous */
    ap_autonMgr = new WsAutonomousMgr(ap_autoProgSelector, ap_autoPositionSelector,
                                      ap_autoDelaySelector, ap_autoLockinSwitch,
                                      ap_dsLockInLed);

    ap_autonMgr->assignDriveBase(ap_driveBase);
    ap_autonMgr->assignAppendages(ap_kicker, ap_accumulator);
    ap_autonMgr->assignPresetWheelButton(ap_calibrateEnableButton);

    /********************
     * Start other tasks
     ********************/
#if ENABLE_VISION_TASK
    g_visionSemaphore = semMCreate(SEM_DELETE_SAFE | SEM_INVERSION_SAFE |
        SEM_Q_PRIORITY);
    memset(&g_visionData, 0, sizeof(g_visionData));
    g_visionTask.Start();
#endif
    if(ap_calib->isCompetitionRobot())

    {
        printf("**********  Real Robot     ***********\n");
    }
    else
    {
        printf("**********  Proto Robot    ***********\n");
    }

    printf("**********  Init complete  ***********\n");
}

WsRobot2010::~WsRobot2010()
{
    /***** Compressor *****/
    delete ap_compressor;
    ap_compressor = NULL;

    delete ap_ballPossessLED;
    ap_ballPossessLED = NULL;


    /********************
     * Inputs
     ********************/

    /***** Joysticks & Gamepads *****/
    delete ap_driveGamepad;
    ap_driveGamepad = NULL;

    delete ap_appendageGamepad;
    ap_appendageGamepad = NULL;

    delete ap_pidTunerGamepad;
    ap_pidTunerGamepad = NULL;

    delete ap_oiGamepad;
    ap_oiGamepad = NULL;

    /***** Individual axis & sticks *****/
    delete ap_driveAxisX;
    ap_driveAxisX = NULL;

    delete ap_driveAxisY;
    ap_driveAxisY = NULL;

    delete ap_crabAxisX;
    ap_crabAxisX = NULL;

    delete ap_crabAxisY;
    ap_crabAxisY = NULL;

    delete ap_driveStick;
    ap_driveStick = NULL;

    delete ap_crabStick;
    ap_crabStick = NULL;

    /***** Buttons *****/
    /* Drive */
    delete ap_turboButton;
    ap_turboButton = NULL;

    delete ap_crabReorientButton;
    ap_crabReorientButton = NULL;

    delete ap_crabDisableButton;
    ap_crabDisableButton = NULL;

    delete ap_crabManualButton;
    ap_crabManualButton = NULL;

    delete ap_crabManualSlowButton;
    ap_crabManualSlowButton = NULL;

#if TEST_VEL_PID
    delete ap_tempVelocityPidTestButton;
    ap_tempVelocityPidTestButton = NULL;
#endif

    /* Appendages */
    delete ap_accumInButton;
    ap_accumInButton = NULL;

    //delete ap_accumOutButton;
    //ap_accumOutButton = NULL;

    delete ap_accumBarRaiseButton;
    ap_accumBarRaiseButton = NULL;

    delete ap_prepKickButton;
    ap_prepKickButton = NULL;

    delete ap_stowKickerButton;
    ap_stowKickerButton = NULL;

    delete ap_kickHighButton;
    ap_kickHighButton = NULL;

    delete ap_kickLowButton;
    ap_kickLowButton = NULL;

    delete ap_kickBabyButton;
    ap_kickBabyButton = NULL;

    delete ap_kickBabyHighButton;
    ap_kickBabyHighButton = NULL;

    delete ap_kickRangeNearButton;
    ap_kickRangeNearButton = NULL;

    delete ap_kickRangeFarButton;
    ap_kickRangeFarButton = NULL;

    delete ap_releaseArmsButton;
    ap_releaseArmsButton = NULL;

    delete ap_releaseTowerAlignButton;
    ap_releaseTowerAlignButton = NULL;

    delete ap_toggleTowerFingersButton;
    ap_toggleTowerFingersButton = NULL;

    delete ap_winchSlowSafetyButton;
    ap_winchSlowSafetyButton = NULL;

    delete ap_winchFullSafetyButton;
    ap_winchFullSafetyButton = NULL;

    delete ap_winchDriveAxis;
    ap_winchDriveAxis = NULL;

    delete ap_cameraUpButton;
    ap_cameraUpButton = NULL;

    delete ap_pneumaticsDisable;
    ap_pneumaticsDisable = NULL;

    delete ap_swDisable;
    ap_swDisable = NULL;

    /* Autonomous */
    delete ap_autoProgSelector;
    ap_autoProgSelector = NULL;

    delete ap_autoPositionSelector;
    ap_autoPositionSelector = NULL;

    delete ap_autoLockinSwitch;
    ap_autoLockinSwitch = NULL;

    delete ap_autoDelaySelector;
    ap_autoDelaySelector = NULL;

    /* Other */
    delete ap_calibrateEnableButton;
    ap_calibrateEnableButton = NULL;

    delete ap_calibrateCrabPotLeftButton;
    ap_calibrateCrabPotLeftButton = NULL;

    delete ap_calibrateCrabPotMidButton;
    ap_calibrateCrabPotMidButton = NULL;

    delete ap_calibrateCrabPotRightButton;
    ap_calibrateCrabPotRightButton = NULL;

    delete ap_tunePidButton;
    ap_tunePidButton = NULL;

    delete ap_pidTuneParamSelectNextButton;
    ap_pidTuneParamSelectNextButton = NULL;

    delete ap_pidTuneParamSelectPrevButton;
    ap_pidTuneParamSelectPrevButton = NULL;

    delete ap_pidTuneParamIncrButton;
    ap_pidTuneParamIncrButton = NULL;

    delete ap_pidTuneParamDecrButton;
    ap_pidTuneParamDecrButton = NULL;

    delete ap_pidTuneRunStepTestButton;
    ap_pidTuneRunStepTestButton = NULL;

    delete ap_pidTuneRunPidButton;
    ap_pidTuneRunPidButton = NULL;

    delete ap_pidTuneControlAxis;
    ap_pidTuneControlAxis = NULL;

    /***** Input Control Objects *****/
    delete ap_controlMethodCrab;
    ap_controlMethodCrab = NULL;

    delete ap_appendageController;
    ap_appendageController = NULL;

    /********************
     * Sensors
     ********************/
    delete ap_crabPot;
    ap_crabPot = NULL;

    delete ap_camera;
    ap_camera = NULL;

    delete ap_analogPressureSensor;
    ap_analogPressureSensor = NULL;

    delete ap_encoderFL;
    ap_encoderFL = NULL;

    delete ap_encoderBR;
    ap_encoderBR = NULL;

    //delete ap_armLimit;
    //ap_armLimit = NULL;

    delete ap_ballPossessedLimit;
    ap_ballPossessedLimit = NULL;

    /********************
     * PID Controllers
     ********************/
    delete ap_crabPID;
    ap_crabPID = NULL;

    delete ap_crabAlignPID;
    ap_crabAlignPID = NULL;

    delete ap_driveVelocityPID;
    ap_driveVelocityPID = NULL;

    /********************
     * Outputs
     ********************/

    /***** Speed Controllers *****/
    delete ap_scDriveFL;
    ap_scDriveFL = NULL;

    delete ap_scDriveFR;
    ap_scDriveFR = NULL;

    delete ap_scDriveBL;
    ap_scDriveBL = NULL;

    delete ap_scDriveBR;
    ap_scDriveBR = NULL;

    delete ap_scCrabL;
    ap_scCrabL = NULL;

    delete ap_scCrabR;
    ap_scCrabR = NULL;

    delete ap_scAccumulator;
    ap_scAccumulator = NULL;

    //delete ap_scWinch;
    //ap_scWinch = NULL;

    /***** Servos *****/
    //delete ap_servTowerAlign;
    //ap_servTowerAlign = NULL;

    delete ap_servCamera;
    ap_servCamera = NULL;

    /***** Solenoids *****/
    delete ap_solAccumBar;
    ap_solAccumBar = NULL;

    delete ap_solKickerRange;
    ap_solKickerRange = NULL;

    delete ap_solKickerLoft;
    ap_solKickerLoft = NULL;

    delete ap_solKickerTension;
    ap_solKickerTension = NULL;

    delete ap_solKickerLatch;
    ap_solKickerLatch = NULL;

    //delete ap_solWinchBrake;
    //ap_solWinchBrake = NULL;

    //delete ap_solArmDeploy;
    //ap_solArmDeploy = NULL;

    //delete ap_dsolTowerFingers;
    //ap_dsolTowerFingers = NULL;

    /***** Relays *****/

    /***** Robot Output Objects *****/
    delete ap_crabController;
    ap_crabController = NULL;

    delete ap_driveBase;
    ap_driveBase = NULL;

    delete ap_kicker;
    ap_kicker = NULL;

    delete ap_accumulator;
    ap_accumulator = NULL;

    /********************
     * Miscellenaeous
     ********************/
    delete ap_dsLockInLed;
    ap_dsLockInLed = NULL;

    delete ap_autonMgr;
    ap_autonMgr = NULL;

    delete ap_mmgrDriveBase;
    ap_mmgrDriveBase = NULL;

    delete ap_mmgrRobot;
    ap_mmgrRobot = NULL;

    delete ap_crabPidTuner;
    ap_crabPidTuner = NULL;

#if ENABLE_LOG_SERVER
    /* kill the log server task */
    if (g_log_task_die_flag == LOG_TASK_RUNNING)
    {
      g_log_task_die_flag = LOG_TASK_KILL;
      while (g_log_task_die_flag != LOG_TASK_DEAD)
      {
        taskDelay(10);
      }
    }
    g_logServerTask.Stop();
#endif

#if ENABLE_VISION_TASK
    /* kill the vision task cleanly */
#endif
}

void WsRobot2010::DisabledInit(void )
{
    /* Called once when we transition into disabled */
    a_crabCalibrationOn = false;
    ap_controlMethodCrab->clearTurboState();
    ap_kicker->resetState();

    // We'll let the encoders run so we can read it for debug
    ap_encoderFL->Reset();
    ap_encoderFL->Start();

    ap_encoderBR->Reset();
    ap_encoderBR->Start();
}

void WsRobot2010::AutonomousInit(void )
{
    /* Called once when we transition into autonomous */
    a_crabCalibrationOn = false;

    // Stop and clear the encoders.  Autonomous steps will start them as needed
    ap_encoderFL->Stop();
    ap_encoderFL->Reset();

    ap_encoderBR->Stop();
    ap_encoderBR->Reset();

    ap_autonMgr->beginAutonomous();
}

void WsRobot2010::TeleopInit(void )
{
    /* Called once when we transition into teleop */
    a_crabCalibrationOn = false;
    ap_dsLockInLed->turnOff();

    // We'll let the encoders run so we can read it for debug
    ap_encoderFL->Reset();
    ap_encoderFL->Start();

    ap_encoderBR->Reset();
    ap_encoderBR->Start();
}

void WsRobot2010::DisabledPeriodic(void )
{
    /* Called periodically while disabled */
    GetWatchdog().Feed();

    /* Dashboard reset should be the first thing done after feeding watchdog */
    ap_dashboard->resetValues();

    /*
    int i;
    printf("LX: %0.3f LY: %0.3f ",
           ap_oiGamepad->GetLeftX(),
           ap_oiGamepad->GetLeftY());

    for(i = 1; i < 13; i++)
    {
    printf("%d: %d ",
           i, ap_oiGamepad->GetNumberedButton(i));
    }
    printf("\n");
    */
    //printf("DPAD: %d  ", ap_driveGamepad->GetDPad());

#if ENABLE_VISION_TASK
    ap_camera->findCandidates();
#endif

    if(IsDisabled())
    {
        ap_autonMgr->processLockin();
    }

    DriverStation *p_ds = DriverStation::GetInstance();

#if OI_TEST
    runOiTest();
#endif

    if (p_ds->IsAutonomous())
    {
        WsAutonomousMgr::StartingPositionT position;
        int progNum;
        //char *progName = "Sleeper";
        char autonString[21];
        char progName[PROG_NAME_LEN];
        bool lockState;

        memset(progName, 0, PROG_NAME_LEN);
        memset(autonString, 0, 21);

        position = ap_autonMgr->getPosition();
        progNum = ap_autonMgr->getProgNum();
        ap_autonMgr->getProgName(progName);
        lockState = ap_autonMgr->getLockState();
        snprintf(autonString, 21, "(%d,%d) %-10s",
                                   position, progNum, progName);


        ap_dsLcd->ClearBuffer();
        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "%s L:%d", autonString, lockState);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Pos: %d", position);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1, "Prog: %d", progNum);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line4, 1, "Lock: %d", lockState);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line5, 1, "%-21s", autonString);
        ap_dsLcd->UpdateLCD();
    }
    else
    {
      if (processCalibration() == false)
      {
        printLcdRegularData();
      }
    }

    ap_kicker->setCommand(WsKicker::KICKER_CMD_NONE);
    ap_accumulator->setState(WsAccumulator::ACCUM_OFF);
    ap_accumulator->setBarState(WsAccumulator::BAR_DEFAULT);
    ap_appendageController->stopAccumulator();

    ap_ballPossessLED->Set(ap_kicker->isBallPossessed());

    if(ap_resetEncodersButton != NULL &&
       ap_encoderFL != NULL &&
       ap_encoderBR != NULL)
    {
        if(ap_resetEncodersButton->getState() == true)
        {
            ap_encoderFL->Reset();
            ap_encoderBR->Reset();
        }
    }
    
    if(ap_accumInButton != NULL)
    {
      ap_accumInButton->resetState();
    }


#if ENABLE_DASHBOARD
    dashboardDisplayInputs();
    dashboardDisplayCrab();
    dashboardDisplayOutput();
    dashboardDisplayAppendageInput();
    dashboardDisplayAppendageOutput();
    dashboardDisplayVision();
    dashboardDisplaySensors();
    dashboardDisplayGeneral();
    dashboardDisplayPidTuning();
    dashboardDisplayAutonomous();

    ap_dashboard->update();
#endif
    //printf("\n");
    a_continuousLoopCounter = 0;
}

void WsRobot2010::AutonomousPeriodic(void )
{
    /* Called periodically while autonomous */
    GetWatchdog().Feed();
    /* Dashboard reset should be the first thing done after feeding watchdog */
    ap_dashboard->resetValues();

    ap_autonMgr->run();

    // The dashboard update should be the last thing done in this function
#if ENABLE_DASHBOARD
    ap_dashboard->update();
#endif
    ap_ballPossessLED->Set(ap_kicker->isBallPossessed());

    a_continuousLoopCounter = 0;
}

void WsRobot2010::TeleopPeriodic(void )
{
    /* Called periodically while teleop */
    WsDriveVector v;
    float crabWheelAngle;
    float crabManualSpeed;
    WsAccumulator::WsAccumStateT accumState;
    WsAccumulator::WsBarStateT barState;
    WsKicker::WsKickerCommandT kickerCommand;
    static bool prevStowState = false;
    static bool prevAccumState = false;
    static bool barOverride = false;
    bool stowState = false;
    bool kickerStowed = false;
#if TEST_VEL_PID
    static bool prevVelocityPidTestButton = false;
#endif

    GetWatchdog().Feed();

    /* Dashboard reset should be the first thing done after feeding watchdog */
    ap_dashboard->resetValues();

#if ENABLE_VISION_TASK
    ap_camera->findCandidates();
#endif

    if(ap_swDisable->getState() == true)
    {
        v.a_speed = 0;
        v.a_direction = 0;
        v.a_x = 0;
        v.a_y = 0;
        ap_driveBase->setVector(&v);

        ap_appendageController->stopAccumulator();
        ap_accumulator->setState(WsAccumulator::ACCUM_OFF);
        ap_accumulator->setBarState(WsAccumulator::BAR_DEFAULT);

        ap_kicker->resetState();
        ap_kicker->setCommand(WsKicker::KICKER_CMD_NONE);
        ap_compressor->Stop();
    }
#if TEST_VEL_PID
    else if(ap_tempVelocityPidTestButton->getState() == true)
    {
        static INT32 previousCount = 0;
        static UINT8 testState = 0;
        float speedAdjustment = 0;
        float baseSpeed = .2;

        int desiredSpeed = 15;
        int desiredCount = 200;

#if 1
        if(prevVelocityPidTestButton == false)
        {
            previousCount = 0;
            testState = 0;
            ap_encoderBR->resetRelCount();
            //ap_encoderFL->resetRelCount();
            ap_driveVelocityPID->resetErrorSum();
        }

        INT32 currentCount = ap_encoderBR->getRelCount();
        //INT32 currentCount = ap_encoderFL->getRelCount();
        ap_driveBase->setCrabAngle(0);
        v.a_direction = 0;

        if(testState == 0)
        {
            desiredCount = 400;
            ap_driveVelocityPID->setMaxOutput(.6);
            ap_driveVelocityPID->setErrorEpsilon(50);
        }
        else if(testState == 1)
        {
            desiredCount = 300;
            ap_driveVelocityPID->setMaxOutput(.3);
            ap_driveVelocityPID->setErrorEpsilon(50);
        }
        else
        {
            ap_driveVelocityPID->setErrorEpsilon(1);
            desiredCount = 0;
        }

        ap_driveVelocityPID->setDesiredValue(desiredCount);
        speedAdjustment = ap_driveVelocityPID->calcPid(currentCount);

        if(ap_driveVelocityPID->isDone() == true)
        {
            speedAdjustment = 0;
            testState++;
            ap_encoderBR->resetRelCount();
            //ap_encoderFL->resetRelCount();
            ap_driveVelocityPID->resetErrorSum();
        }

        v.a_speed =  speedAdjustment;

        if(v.a_speed > 1.0)
        {
            v.a_speed = 1.0;
        }
        else if(v.a_speed < -1.0)
        {
            v.a_speed = -1.0;
        }

        printf("%d - %5d %5d (%5d) %f %f\n", testState, desiredCount, currentCount, (desiredCount - currentCount), speedAdjustment, v.a_speed);
        ap_driveBase->setVector(&v);

#else


        //int currentSpeed = (int)ap_encoderFL->GetRate();
        INT32 currentCount = ap_encoderBR->Get();

        if(previousCount == -999)
        {
            previousCount = currentCount;
        }


        INT32 currentSpeed = currentCount - previousCount;


        ap_driveBase->setCrabAngle(0);
        v.a_direction = 0;

        ap_driveVelocityPID->setDesiredValue(desiredSpeed);
        speedAdjustment = ap_driveVelocityPID->calcPid(currentSpeed);

        if(ap_driveVelocityPID->isDone() == true)
        {
            speedAdjustment = 0;
        }



        v.a_speed = baseSpeed + speedAdjustment;

        if(v.a_speed > 1.0)
        {
            v.a_speed = 1.0;
        }
        else if(v.a_speed < -1.0)
        {
            v.a_speed = -1.0;
        }

        printf("%5d %5d (%5d) %f %f\n", desiredSpeed, currentSpeed, (desiredSpeed - currentSpeed), speedAdjustment, v.a_speed);
        ap_driveBase->setVector(&v);

        ap_dsLcd->ClearBuffer();

        ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "d: %3d c: %3d o: %3f",
                desiredSpeed, currentSpeed, v.a_speed);
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "d: %3d c: %3d o: %3f",
                desiredSpeed, currentSpeed, v.a_speed);
        ap_dsLcd->UpdateLCD();


        previousCount = currentCount;
#endif
    }
#endif
    else if(tuneCrabPid() == false)
    {
        ap_compressor->Start();
        /*
         * Get drive base inputs & pass to drive base
         */
        // printf("DPAD: %d  ", ap_driveGamepad->GetDPad());
        v = ap_controlMethodCrab->getDriveVector();

        if (ap_controlMethodCrab->getCrabEnableState() == true)
        {
            crabWheelAngle = ap_controlMethodCrab->getCrabWheelAngle();
            ap_driveBase->useAlignPid(ap_calibrateEnableButton->getState());
            ap_driveBase->setCrabAngle(crabWheelAngle);
        }
        else
        {
            crabManualSpeed = ap_controlMethodCrab->getCrabManualSpeed();
            ap_driveBase->setManualSpeed(crabManualSpeed);
        }

        ap_driveBase->setVector(&v);

        /*
         * Get appendage commands from inputs & pass to appendages
         */
        accumState = ap_appendageController->getAccumulatorCommand();
        barState = ap_appendageController->getAccumulatorBarCommand();

        ap_accumulator->setState(accumState, ap_kicker->isKicking());

        stowState = ap_stowKickerButton->getState();
        kickerStowed = ap_kicker->isStowed();


        if(kickerStowed == false)
        {
            if(stowState == true)
            {
                barOverride = true;
            }
            else
            {
                barOverride = false;
            }
        }
        else
        {
            if(accumState != WsAccumulator::ACCUM_OFF &&
               accumState != prevAccumState)
            {
                barOverride = false;
            }
            else if(barState == true)
            {
                barOverride = false;
            }
            else if(stowState == true)
            {
                barOverride = true;
            }
        }




        /*


        if(stowState == true)
        {
            if(prevStowState != stowState)
            {
                barOverride = true;
            }
            else if(accumState != WsAccumulator::ACCUM_OFF &&
                    accumState != prevAccumState)
            {
                barOverride = false;
            }
            else if(barState == true)
            {
                barOverride = false;
            }
        }
        else
        {
            if(!ap_kicker->isStowed())
            {
                barOverride = false;
            }
        }
        */

        ap_accumulator->setBarState(barState, barOverride);

        prevStowState = stowState;
        prevAccumState = accumState;


        kickerCommand = ap_appendageController->getKickerCommand();
        ap_kicker->setCommand(kickerCommand);


        ap_ballPossessLED->Set(ap_kicker->isBallPossessed());

        if(ap_calib->isCompetitionRobot())
        {
            if(ap_cameraUpButton->getState() == true)
            {
                ap_servCamera->Set(.95);
            }
            else
            {
                ap_servCamera->Set(.75);
            }
        }
        else
        {
            if(ap_cameraUpButton->getState() == true)
            {
                ap_servCamera->Set(.5);
            }
            else
            {
                ap_servCamera->Set(.25);
            }
        }
    }

    //printLcdRegularData();

#if ENABLE_DASHBOARD
    dashboardDisplayInputs();
    dashboardDisplayCrab();
    dashboardDisplayOutput();
    dashboardDisplayAppendageInput();
    dashboardDisplayAppendageOutput();
    dashboardDisplayVision();
    dashboardDisplaySensors();
    dashboardDisplayGeneral();
    dashboardDisplayPidTuning();
    dashboardDisplayAutonomous();

    ap_dashboard->update();
#endif

#if TEST_VEL_PID
    prevVelocityPidTestButton = ap_tempVelocityPidTestButton->getState();
#endif
    a_continuousLoopCounter = 0;
}

void WsRobot2010::DisabledContinuous(void )
{
    /* Called every loop while disabled */
    a_continuousLoopCounter++;
}

void WsRobot2010::AutonomousContinuous(void )
{
    /* Called every loop while continuous */
    a_continuousLoopCounter++;
}


void WsRobot2010::TeleopContinuous(void )
{
    /* Called every loop while teleop */
    a_continuousLoopCounter++;
}

bool WsRobot2010::processCalibration(void)
{
    static UINT8 ledCounter = 0;
    //static bool ledOn = false;
    static bool prevCalibrationMode = false;
    static bool saveData = false;

    INT32 currentCrab;

    a_calibrationMode = ap_calibrateEnableButton->getState();

    currentCrab = ap_crabPot->GetAverageValue();

    if(currentCrab < 0)
    {
        currentCrab = 0;
    }

    if(a_calibrationMode == true)
    {
        ap_dsLcd->ClearBuffer();
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1,
                         "Crab Calibration Mode");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                         "        L   M   R ");
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line4, 1,
                         "Saved: %3d %3d %3d",
                         ap_calib->getValue(WsCalibration::CRAB_LEFT),
                         ap_calib->getValue(WsCalibration::CRAB_MID),
                         ap_calib->getValue(WsCalibration::CRAB_RIGHT));
        ap_dsLcd->Printf(DriverStationLCD::kUser_Line5, 1,
                         "Curr:      %3d", currentCrab);

        if(ap_calibrateCrabPotLeftButton->getState() == true)
        {
            ap_calib->setValue(WsCalibration::CRAB_LEFT, currentCrab);
            saveData = true;
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib L: %3d", currentCrab);
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                             "       -L-        ");
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1,
                             "L Calib Saved: %3d", currentCrab);
        }
        else if(ap_calibrateCrabPotMidButton->getState() == true)
        {
            ap_calib->setValue(WsCalibration::CRAB_MID, currentCrab);
            saveData = true;
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib M: %3d", currentCrab);
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                             "           -M-    ");
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1,
                             "M Calib Saved: %3d", currentCrab);
        }
        else if(ap_calibrateCrabPotRightButton->getState() == true)
        {
            ap_calib->setValue(WsCalibration::CRAB_RIGHT, currentCrab);
            saveData = true;
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib R: %3d", currentCrab);
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line3, 1,
                             "               -R-");
            ap_dsLcd->Printf(DriverStationLCD::kUser_Line6, 1,
                             "R Calib Saved: %3d", currentCrab);
        }
        else
        {
            ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1,
                             "Crab Calib (Curr=%3d)", currentCrab);
        }
        ap_dsLcd->UpdateLCD();
    }

    if((saveData == true) &&
       (prevCalibrationMode != a_calibrationMode) &&
       (a_calibrationMode == false))
    {
        ap_calib->saveData();
        saveData = false;
        a_crabCalibrationOn = true;
    }

#if 1
    if(ledCounter < 50)
    {
        ledCounter++;
    }
    else
    {
        ledCounter = 0;
        a_crabCalibrationOn = false;
    }
#endif

    prevCalibrationMode = a_calibrationMode;

    return a_calibrationMode;
}

bool WsRobot2010::tuneCrabPid()
{
#if ENABLE_PID_TUNING
    bool ret = false;
    bool setOutput = false;
    // Should be based on calibration switch, but that seems broken
    //a_calibrationMode = ap_calibrateEnableButton->getState();
    //printf("CALIB MODE %d %d\n", a_calibrationMode, (a_calibrationMode == true));
    if(1)
    {
        printf("DPAD: %d  ", ap_pidTunerGamepad->GetDPad());
        if(!ap_crabPidTuner->isTuning())
        {
            printf("Start tuning\n");
            ap_crabPidTuner->init();
        }

        setOutput = ap_crabPidTuner->processTuning();

        ret = true;
    }
    else
    {
        if(ap_crabPidTuner->isTuning())
        {
            printf("Finish tuning\n");
            ap_crabPidTuner->finish();
        }
    }
  return ret;
#else
  return false;
#endif
}

void WsRobot2010::runOiTest(void)
{
    static int ledCounter = 0;
    static int currentLedOn = 1;

    /*
       printf("%d %d %d %d %d %d %d %d %8.3f %8.3f %8.3f %8.3f\n",
       p_ds->GetDigitalIn(1),
       p_ds->GetDigitalIn(2),
       p_ds->GetDigitalIn(3),
       p_ds->GetDigitalIn(4),
       p_ds->GetDigitalIn(5),
       p_ds->GetDigitalIn(6),
       p_ds->GetDigitalIn(7),
       p_ds->GetDigitalIn(8),
       p_ds->GetAnalogIn(1),
       p_ds->GetAnalogIn(2),
       p_ds->GetAnalogIn(3),
       p_ds->GetAnalogIn(4));
     */

    ap_dsLockInLed->turnOff();

    switch(currentLedOn)
    {
        case 1:
            ap_dsLockInLed->blink(10);
            break;
        default:
            break;
    }
#if 0
    ap_dsLockInLed->blink(.5);
    ap_dsLED2->blink(.25);
    ap_dsLED3->blink(1);
#endif

    if(ledCounter > 50)
    {
        ledCounter = 0;
        currentLedOn++;
        if(currentLedOn == 5)
        {
            currentLedOn = 1;
        }
    }
    else
    {
        ledCounter++;
    }
}

void WsRobot2010::dashboardDisplayInputs(void)
{
    if(ap_driveGamepad != NULL)
    {
        ap_dashboard->setValue(IDX_IN_DRIVE_X, ap_driveStick->GetX());
        ap_dashboard->setValue(IDX_IN_DRIVE_Y, ap_driveStick->GetY());
        ap_dashboard->setValue(IDX_IN_DRIVE_RADIUS, ap_driveStick->GetRadius());
        ap_dashboard->setValue(IDX_IN_DRIVE_ANGLE, ap_driveStick->GetAngle());
        ap_dashboard->setValue(IDX_IN_DRIVE_TURBO, ap_controlMethodCrab->getTurboState());
        ap_dashboard->setValue(IDX_IN_DRIVE_BUTTON_2, false);
        ap_dashboard->setValue(IDX_IN_DRIVE_BUTTON_3, false);
        ap_dashboard->setValue(IDX_IN_DRIVE_BUTTON_4, false);

        ap_dashboard->setValue(IDX_IN_CRAB_X, ap_crabStick->GetX());
        ap_dashboard->setValue(IDX_IN_CRAB_Y, ap_crabStick->GetY());
        ap_dashboard->setValue(IDX_IN_CRAB_RADIUS, ap_crabStick->GetRadius());
        ap_dashboard->setValue(IDX_IN_CRAB_ANGLE, ap_crabStick->GetAngle());
        ap_dashboard->setValue(IDX_IN_CRAB_DISABLE, ap_crabDisableButton->getState());
        ap_dashboard->setValue(IDX_IN_CRAB_MANUAL, ap_crabManualButton->getState());

        ap_dashboard->setValue(IDX_IN_ENCODER1_VALUE, ap_encoderFL->getAbsCount());
        ap_dashboard->setValue(IDX_IN_ENCODER1_DIST, (float)ap_encoderFL->GetDistance());
        ap_dashboard->setValue(IDX_IN_ENCODER1_RATE, (float)ap_encoderFL->GetRate());
        ap_dashboard->setValue(IDX_IN_ENCODER2_VALUE, ap_encoderBR->getAbsCount());
        ap_dashboard->setValue(IDX_IN_ENCODER2_DIST, (float)ap_encoderBR->GetDistance());
        ap_dashboard->setValue(IDX_IN_ENCODER2_RATE, (float)ap_encoderBR->GetRate());
    }

}

void WsRobot2010::dashboardDisplayCrab(void)
{
    INT32 currentCrab = 0;
    if(ap_crabPot != NULL)
    {
        currentCrab = ap_crabPot->GetAverageValue();
        if(currentCrab < 0)
        {
            currentCrab = 0;
        }
    }

    // This is done here so we can see the values while disabled
    ap_dashboard->setValue(IDX_CRAB_CURRENT_POT, (UINT32)currentCrab);
    ap_dashboard->setValue(IDX_CRAB_PID_TARGET, (UINT32)ap_crabPID->getDesiredValue());
    ap_dashboard->setValue(IDX_CRAB_PID_P, ap_crabPID->getP());
    ap_dashboard->setValue(IDX_CRAB_PID_I, ap_crabPID->getI());
    ap_dashboard->setValue(IDX_CRAB_PID_D, ap_crabPID->getD());
    ap_dashboard->setValue(IDX_CRAB_PID_EPS, (float)ap_crabPID->getEpsilon());
    ap_dashboard->setValue(IDX_CRAB_CALIB_LEFT, ap_calib->getValue(WsCalibration::CRAB_LEFT));
    ap_dashboard->setValue(IDX_CRAB_CALIB_MID, ap_calib->getValue(WsCalibration::CRAB_MID));
    ap_dashboard->setValue(IDX_CRAB_CALIB_RIGHT, ap_calib->getValue(WsCalibration::CRAB_RIGHT));
}

void WsRobot2010::dashboardDisplayOutput(void)
{
    ap_dashboard->setValue(IDX_OUT_DRIVE_FL, ap_scDriveFL->Get());
    ap_dashboard->setValue(IDX_OUT_DRIVE_FR, ap_scDriveFR->Get());
    ap_dashboard->setValue(IDX_OUT_DRIVE_BL, ap_scDriveBL->Get());
    ap_dashboard->setValue(IDX_OUT_DRIVE_BR, ap_scDriveBR->Get());
    ap_dashboard->setValue(IDX_OUT_CRAB_L, ap_scCrabL->Get());
    ap_dashboard->setValue(IDX_OUT_CRAB_R, ap_scCrabR->Get());
}


void WsRobot2010::dashboardDisplayAppendageInput(void)
{
    ap_dashboard->setValue(IDX_APPENDAGE_IN_ACCUM_IN, ap_accumInButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_ACCUM_OUT, false);//ap_accumOutButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_ACCUM_BAR_UP, ap_accumBarRaiseButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_RANGE_NEAR, ap_kickRangeNearButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_RANGE_FAR, ap_kickRangeFarButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_PREPARE_KICKER, ap_prepKickButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_KICK_LOW, ap_kickLowButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_KICK_HIGH, ap_kickHighButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_KICK_BABY, ap_kickBabyButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_STOW, ap_stowKickerButton->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_KICKER_CMD, (UINT32)ap_appendageController->getKickerCommand());
    ap_dashboard->setValue(IDX_APPENDAGE_IN_BALL_POSSESSED, ap_kicker->isBallPossessed());
}

void WsRobot2010::dashboardDisplayAppendageOutput(void)
{
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_KICKER_ENABLE, ap_kicker->getEnabled());
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_RANGE, (ap_kicker->getKickerRange() == WsKickerRange::KICKER_RANGE_NEAR) ? true : false);
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_LOFT, (ap_kicker->getKickerLoft() == WsKickerLoft::KICKER_LOFT_HIGH) ? true : false);
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_TENSIONER, (ap_kicker->getKickerTension() == WsKickerTensioner::KICKER_TENSION_DOWN) ? true : false);
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_LATCH, (ap_kicker->getKickerLatch() == WsKickerLatch::KICKER_LATCH_RELEASE) ? true : false);
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_ACCUM, (UINT32) ap_accumulator->getState());
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_KICKER_STATE, (UINT32) ap_kicker->getKickerState());
    ap_dashboard->setValue(IDX_APPENDAGE_OUT_BAR_STATE, ap_accumulator->isBarUp());
}


void WsRobot2010::dashboardDisplaySensors(void)
{
}

void WsRobot2010::dashboardDisplayGeneral(void)
{
    static UINT32 testInt = 0;
    static float testFloat = 0.0;
    static bool testBool = false;

    static float pressure = 0;
    if((testInt % 2) == 0)
    {
      if(ap_analogPressureSensor != NULL)
      {
        pressure = (ap_analogPressureSensor->GetAverageValue() - 100) / (float)6;
      }
    }

    //printf("PRESSURE: RAW %f PSI: %f\n", (float)ap_analogPressureSensor->GetAverageValue(), pressure);

    ap_dashboard->setValue(IDX_GENERAL_TEST_INT, testInt);
    //ap_dashboard->setValue(IDX_GENERAL_TEST_INT, a_continuousLoopCounter);
    ap_dashboard->setValue(IDX_GENERAL_TEST_FLOAT, testFloat);
    ap_dashboard->setValue(IDX_GENERAL_TEST_BOOL, testBool);
    ap_dashboard->setValue(IDX_GENERAL_ANALOG_PRESSURE, pressure);
    ap_dashboard->setValue(IDX_GENERAL_SW_DISABLE, ap_swDisable->getState());

    testFloat += .01;

    if(!(testInt % 5))
    {
        testBool = !testBool;
    }
    testInt++;
}

void WsRobot2010::dashboardDisplayPidTuning(void)
{
    ap_dashboard->setValue(IDX_CRAB_TUNING_ENABLED, ap_crabPidTuner->getEnableState());
    ap_dashboard->setValue(IDX_CRAB_TUNING_TESTING, ap_crabPidTuner->getTestingState());
    ap_dashboard->setValue(IDX_CRAB_TUNING_P, ap_crabPidTuner->getP());
    ap_dashboard->setValue(IDX_CRAB_TUNING_I, ap_crabPidTuner->getI());
    ap_dashboard->setValue(IDX_CRAB_TUNING_D, ap_crabPidTuner->getD());
    ap_dashboard->setValue(IDX_CRAB_TUNING_EPS, ap_crabPidTuner->getEps());
    ap_dashboard->setValue(IDX_CRAB_TUNING_INCR_SMALL, ap_crabPidTuner->getIncrSmall());
    ap_dashboard->setValue(IDX_CRAB_TUNING_INCR_LARGE, ap_crabPidTuner->getIncrLarge());
    ap_dashboard->setValue(IDX_CRAB_TUNING_STEP_SIZE, ap_crabPidTuner->getStepFuncSize());
    ap_dashboard->setValue(IDX_CRAB_TUNING_SET_POINT, ap_crabPidTuner->getSetPoint());
    ap_dashboard->setValue(IDX_CRAB_TUNING_CURRENT_VALUE, ap_crabPidTuner->getCurrentValue());
    ap_dashboard->setValue(IDX_CRAB_TUNING_OUTPUT, ap_crabPidTuner->getOutput());
    ap_dashboard->setValue(IDX_CRAB_TUNING_CURRENT_PARAM, ap_crabPidTuner->getCurrentParam());
}

void WsRobot2010::dashboardDisplayAutonomous(void)
{
    ap_dashboard->setValue(IDX_AUTO_PROG_NUM, (UINT32)ap_autonMgr->getProgNum());
    ap_dashboard->setValue(IDX_AUTO_START_LOC, (UINT32)ap_autonMgr->getPosition());
    ap_dashboard->setValue(IDX_AUTO_START_DELAY, ap_autonMgr->getStartDelay());
    ap_dashboard->setValue(IDX_AUTO_LOCK, ap_dsLockInLed->getState());
}


void WsRobot2010::dashboardDisplayVision(void)
{
  return;
    std::vector<WsVisionTarget> targets;

#if ENABLE_VISION_TASK
    ap_camera->getAllCandidates(targets);
#else
    WsVisionTarget target1;
    target1.a_majorRadius = .5;
    target1.a_minorRadius = .5;
    target1.a_rawScore = .5;
    target1.a_xPos = 0;
    target1.a_yPos = 0;
    target1.a_score = .5;
    target1.a_rotation = 0;

    WsVisionTarget target2;
    target2.a_majorRadius = .7;
    target2.a_minorRadius = .7;
    target2.a_rawScore = .4;
    target2.a_xPos = 0;
    target2.a_yPos = 0;
    target2.a_score = .4;
    target2.a_rotation = 0;

    targets.push_back(target1);
    targets.push_back(target2);
#endif

    ap_dashboard->setValue(IDX_VISION_DATA, targets);
}

void WsRobot2010::printLcdRegularData(void)
{
  UINT32 crabPos;

  ap_dsLcd->ClearBuffer();

  crabPos = ap_crabPot->GetAverageValue();

  ap_dsLcd->Printf(DriverStationLCD::kMain_Line6, 1, "Crab pot: %3d",
      crabPos);
  ap_dsLcd->Printf(DriverStationLCD::kUser_Line2, 1, "Crab pot: %3d",
      crabPos);
  ap_dsLcd->UpdateLCD();
}

