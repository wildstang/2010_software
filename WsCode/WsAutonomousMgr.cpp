//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Wildstang
//  @ File Name : WsAutonomousMgr.cpp
//  @ Date : 2/8/2009
//  @ Author : 
//
//

#include <string.h>

#include "WsAutonomousMgr.h"
#include "WsDsAnalog.h"
#include "WsControllerAxis.h"
#include "WsControllerButton.h"
#include "WsAutoProgramBase.h"

#include "WsAutoSleeper.h"
#include "WsAutoFarLeftKick3.h"
#include "WsAutoFarRightKick3.h"
#include "WsAutoFarRightKick3ClearCross.h"
#include "WsAutoFarRightKick3FFF.h"
#include "WsAutoFarRightKick3FNF.h"
#include "WsAutoFarRightKick3CrossFFF.h"
#include "WsAutoFarRightKick3CrossFNF.h"
#include "WsAutoFarRightKick3Low.h"
#include "WsAutoMidLeftKick2.h"
#include "WsAutoMidRightKick2.h"
#include "WsAutoMidRightKick1.h"
#include "WsAutoNearRightKick1.h"
#include "WsAutoNearKickNoCrab.h"
#include "WsDashboard.h"
#include "WsDriverStationLED.h"

#define HARDCODE_AUTO 0

//TODO MOVE THESE TO BE MEMBERS
#define MAX_NUM_PROG 11
const char progNames[][MAX_NUM_PROG][PROG_NAME_LEN] = {
  /* near */ { "Sleeper", "Sleeper",  "Sleeper",  "NearRKick1", "NearNoCrab", "Sleeper", "Sleeper", "Sleeper", "Sleeper", "Sleeper", "Sleeper"},
  /* mid  */ { "Sleeper", "Sleeper", "Sleeper", "MidRKick2", "MidRKick1", "Sleeper", "Sleeper", "Sleeper", "Sleeper", "Sleeper", "Sleeper"},
  /* far  */ { "Sleeper", "FarLKick3", "Sleeper",   "FarRKick3", "FRClrCrss",
    "FarFFN", "FarFFNCrss", "FarFNF", "FarFNFCrss", "Sleeper", "Sleeper"},
                                                      };

WsAutonomousMgr::WsAutonomousMgr(WsDsAnalog* p_progNumSelector,
                                 WsDsAnalog* p_positionSelector,
                                 WsDsAnalog* p_delaySelector,
                                 WsControllerButton* p_lockInSwitch,
                                 WsDriverStationLED* p_lockInLed)
{
    ap_progNumSelectorDs = p_progNumSelector;
    ap_positionSelectorDs = p_positionSelector;
    ap_delaySelectorDs = p_delaySelector;
    ap_progNumSelectorAxis = NULL;
    ap_positionSelectorAxis = NULL;
    ap_delaySelectorAxis = NULL;
    ap_lockInSwitch = p_lockInSwitch;
    ap_lockInLed = p_lockInLed;
    initializeAutonomousMgr();
}

WsAutonomousMgr::WsAutonomousMgr(WsControllerAxis* p_progNumSelector,
                                 WsControllerAxis* p_positionSelector,
                                 WsControllerAxis* p_delaySelector,
                                 WsControllerButton* p_lockInSwitch,
                                 WsDriverStationLED* p_lockInLed)
{
    ap_progNumSelectorDs = NULL;
    ap_positionSelectorDs = NULL;
    ap_delaySelectorDs = NULL;
    ap_progNumSelectorAxis = p_progNumSelector;
    ap_positionSelectorAxis = p_positionSelector;
    ap_delaySelectorAxis = p_delaySelector;
    ap_lockInSwitch = p_lockInSwitch;
    ap_lockInLed = p_lockInLed;
    initializeAutonomousMgr();
}


void WsAutonomousMgr::initializeAutonomousMgr(void)
{
    ap_presetWheelButton = NULL;

    ap_program = NULL;

    ap_driveBase = NULL;
    ap_kicker = NULL;
    ap_accumulator = NULL;

    a_progNum = 1;
    a_position = START_CLOSE;
    a_delay = WsAutoProgramBase::DELAY_NONE;
    a_lockedIn = false;
    a_presetWheels = false;

    a_hasRun = false;

    memset(a_progName, 0, PROG_NAME_LEN);
    strncpy(a_progName, "Sleeper", PROG_NAME_LEN);

    ap_dashboard = WsDashboard::getInstance();
}

WsAutonomousMgr::~WsAutonomousMgr()
{
    if(ap_program != NULL)
    {
        delete ap_program;
    }
    ap_program = NULL;
}

void WsAutonomousMgr::assignDriveBase(WsDriveBaseCrabSingle* p_driveBase)
{
    ap_driveBase = p_driveBase;
}

void WsAutonomousMgr::assignAppendages( WsKicker* p_kicker, WsAccumulator* p_accumulator)
{
    ap_kicker = p_kicker;
    ap_accumulator = p_accumulator;
}

void WsAutonomousMgr::assignPresetWheelButton(WsControllerButton* p_button)
{
  ap_presetWheelButton = p_button;
}

UINT8 WsAutonomousMgr::getProgNum(void)
{
    if(a_lockedIn == true)
    {
        return a_progNum;
    }
    else
    {
        return a_tempProgNum;
    }

}

float WsAutonomousMgr::getStartDelay(void)
{
    if(a_lockedIn == true)
    {
        return WsAutoProgramBase::convertDelay(a_delay);
    }
    else
    {
        return WsAutoProgramBase::convertDelay(a_tempDelay);
    }
}

bool WsAutonomousMgr::getLockState(void)
{
    return a_lockedIn;
}

void WsAutonomousMgr::getProgName(char* p_name)
{
    if(p_name != NULL)
    {
        strncpy(p_name, a_progName, PROG_NAME_LEN);
    }
}

WsAutonomousMgr::StartingPositionT WsAutonomousMgr::getPosition(void)
{
    if(a_lockedIn == true)
    {
        return a_position;
    }
    else
    {
        return a_tempPosition;
    }
}

void WsAutonomousMgr::processLockin(void )
{
    float progNumValue = 0;
    float delayValue = 0;
    float positionValue;
    bool lockInState;
    static bool lockInStatePrev = true;

    if(ap_presetWheelButton != NULL) 
    {
        a_presetWheels = ap_presetWheelButton->getState();
    }

    if(ap_progNumSelectorDs != NULL)
    {
        progNumValue = ap_progNumSelectorDs->getValue();
    }

    if(ap_progNumSelectorAxis != NULL)
    {
        progNumValue = ap_progNumSelectorAxis->getValue();
    }

    if(ap_positionSelectorDs != NULL)
    {
        positionValue = ap_positionSelectorDs->getValue();
    }

    if(ap_positionSelectorAxis != NULL)
    {
        positionValue = ap_positionSelectorAxis->getValue();
    }

    if(ap_delaySelectorDs != NULL)
    {
        delayValue = ap_delaySelectorDs->getValue();
    }

    if(ap_delaySelectorAxis != NULL)
    {
        delayValue = ap_delaySelectorAxis->getValue();
    }



    lockInState = ap_lockInSwitch->getState();

    //printf("%f %f %f %d\n", progNumValue, positionValue, delayValue, lockInState);

    if(lockInState != lockInStatePrev)
    {
        a_lockedIn = lockInState;
    }


    /* Select the program based on the OI input */
    if((progNumValue >= PROG1_MIN) && 
       (progNumValue <  PROG1_MAX))
    {
        a_tempProgNum = 1;
    }
    else if((progNumValue >= PROG2_MIN) && 
            (progNumValue <  PROG2_MAX))
    {
        a_tempProgNum = 2;
    }
    else if((progNumValue >= PROG3_MIN) && 
            (progNumValue <  PROG3_MAX))
    {
        a_tempProgNum = 3;
    }
    else if((progNumValue >= PROG4_MIN) && 
            (progNumValue <  PROG4_MAX))
    {
        a_tempProgNum = 4;
    }
    else if((progNumValue >= PROG5_MIN) && 
            (progNumValue <  PROG5_MAX))
    {
        a_tempProgNum = 5;
    }
    else if((progNumValue >= PROG6_MIN) && 
            (progNumValue <  PROG6_MAX))
    {
        a_tempProgNum = 6;
    }
    else if((progNumValue >= PROG7_MIN) && 
            (progNumValue <  PROG7_MAX))
    {
        a_tempProgNum = 7;
    }
    else if((progNumValue >= PROG8_MIN) && 
            (progNumValue <  PROG8_MAX))
    {
        a_tempProgNum = 8;
    }
    else if((progNumValue >= PROG9_MIN) && 
            (progNumValue <  PROG9_MAX))
    {
        a_tempProgNum = 9;
    }
#if 0
    else if((progNumValue >= PROG10_MIN) && 
            (progNumValue <  PROG10_MAX))
    {
        a_tempProgNum = 10;
    }
    else if((progNumValue >= PROG11_MIN) && 
            (progNumValue <  PROG11_MAX))
    {
        a_tempProgNum = 11;
    }
#endif
    else
    {
        a_tempProgNum = 1;
    }

    /* Select the start position based on the OI input */
    if((positionValue >= POSITION1_MIN) &&
            (positionValue <= POSITION1_MAX)) // <= because MAX is high voltage
    {
        a_tempPosition = START_CLOSE;
    }
    else if((positionValue >= POSITION2_MIN) &&
            (positionValue < POSITION2_MAX))
    {
        a_tempPosition = START_MID;
    }
    else if((positionValue >= POSITION3_MIN) && // >= because MIN is low voltage
            (positionValue < POSITION3_MAX))
    {
        a_tempPosition = START_FAR;
    }
    else
    {
        a_tempPosition = START_FAR;
    }

    if((delayValue >= AUTO_DELAY0_MIN) &&
            (delayValue <= AUTO_DELAY0_MAX)) // <= because MAX is high voltage
    {
        a_tempDelay = WsAutoProgramBase::DELAY_NONE;
    }
    else if((delayValue >= AUTO_DELAY1_MIN) &&
            (delayValue < AUTO_DELAY1_MAX))
    {
        a_tempDelay = WsAutoProgramBase::DELAY_1;
    }
    else if((delayValue >= AUTO_DELAY2_MIN) && // >= because MIN is low voltage
            (delayValue < AUTO_DELAY2_MAX))
    {
        a_tempDelay = WsAutoProgramBase::DELAY_2;
    }
    else
    {
        a_tempDelay = WsAutoProgramBase::DELAY_NONE;
    }

    if(lockInState == a_lockInStateOff)
    {
        a_progNum = 1;
        a_position = START_CLOSE;
        a_delay = WsAutoProgramBase::DELAY_NONE;
    }
    else if((lockInState == a_lockInStateOn) &&
            (lockInStatePrev == a_lockInStateOff))
    {
        a_progNum = a_tempProgNum;
        a_position = a_tempPosition;
        a_delay = a_tempDelay;

        if(a_hasRun == true)
        {
            a_hasRun = false;
        }
    }

    if(a_hasRun == true)
    {
        a_lockedIn = false;
    }

    // DEBUG
    //lockInState = true;
    //a_progNum = 2;
    //a_position = START_HOME;

    if(a_lockedIn == true)
    {
        ap_lockInLed->turnOn();
    }
    else
    {
        ap_lockInLed->blinkNumber(a_tempProgNum);
    }

    memset(a_progName, 0, PROG_NAME_LEN);
    if((a_tempProgNum >= 1) || (a_tempProgNum <= MAX_NUM_PROG))
    {
        strncpy(a_progName, progNames[a_tempPosition][a_tempProgNum - 1], PROG_NAME_LEN);
    }
    else
    {
        strncpy(a_progName, "Sleeper", PROG_NAME_LEN);
    }

    lockInStatePrev = lockInState;
}

void WsAutonomousMgr::beginAutonomous(void )
{
    if(a_lockedIn == false)
    {
        a_progNum = 1;
    }

    /* TEMPORARY HARD CODE SINCE WE DON'T HAVE THE SWITCHES */
#if HARDCODE_AUTO
    a_position = START_FAR;
    a_progNum = 4;
    a_delay = WsAutoProgramBase::DELAY_NONE;
#endif
    if(ap_program != NULL)
    {
        ap_program->turnOffDriveBase();
        ap_program->turnOffAppendages();
        delete ap_program;
        ap_program = NULL;
    }

    if(a_hasRun == true)
    {
        ap_program = new WsAutoSleeper();
    }
    else
    {
        if(a_position == START_CLOSE)
        {
            switch(a_progNum)
            {
                case 1:
                    ap_program = new WsAutoSleeper();
                    break;
                case 2:
                    ap_program = new WsAutoSleeper();
                    break;
                case 3:
                    ap_program = new WsAutoSleeper();
                    break;
                case 4:
                    ap_program = new WsAutoNearRightKick1();
                    break;
                case 5:
                    ap_program = new WsAutoNearKickNoCrab();
                    break;
                case 6:
                    ap_program = new WsAutoSleeper();
                    break;
                case 7:
                    ap_program = new WsAutoSleeper();
                    break;
                case 8:
                    ap_program = new WsAutoSleeper();
                    break;
                default:
                    ap_program = new WsAutoSleeper();
                    break;
            }
        }
        else if(a_position == START_MID)
        {
            switch(a_progNum)
            {
                case 1:
                    ap_program = new WsAutoSleeper();
                    break;
                case 2:
                    ap_program = new WsAutoSleeper();
                    break;
                case 3:
                    ap_program = new WsAutoSleeper();
                    break;
                case 4:
                    ap_program = new WsAutoMidRightKick2();
                    break;
                case 5:
                    ap_program = new WsAutoMidRightKick1();
                    break;
                case 6:
                    ap_program = new WsAutoSleeper();
                    break;
                case 7:
                    ap_program = new WsAutoSleeper();
                    break;
                case 8:
                    ap_program = new WsAutoSleeper();
                    break;
                default:
                    ap_program = new WsAutoSleeper();
                    break;
            }
        }
        else
        {
            switch(a_progNum)
            {
                case 1:
                    ap_program = new WsAutoSleeper();
                    break;
                case 2:
                    ap_program = new WsAutoFarLeftKick3();
                    break;
                case 3:
                    ap_program = new WsAutoSleeper();
                    break;
                case 4:
                    ap_program = new WsAutoFarRightKick3();
                    break;
                case 5:
                    ap_program = new WsAutoFarRightKick3ClearCross();
                    break;
                case 6:
                    // Written in the FFF File
                    ap_program = new WsAutoFarRightKick3FFN();
                    break;
                case 7:
                    // Written in the FFF File
                    ap_program = new WsAutoFarRightKick3CrossFFN();
                    break;
                case 8:
                    ap_program = new WsAutoFarRightKick3FNF();
                    break;
                case 9:
                    ap_program = new WsAutoFarRightKick3CrossFNF();
                    break;
                default:
                    ap_program = new WsAutoSleeper();
                    break;
            }
        }
    }

    ap_program->setPresetWheels(a_presetWheels);
    ap_program->setStartDelay(a_delay);
    ap_program->assignDriveBase(ap_driveBase);
    ap_program->assignAppendages(ap_kicker, ap_accumulator);

    a_hasRun = true;

    ap_program->initParams();

}

bool WsAutonomousMgr::run(void )
{
    bool done = true;

    if(ap_program != NULL)
    {
        done = ap_program->run();
    }

    return done;
}

